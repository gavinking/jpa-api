//
// Copyright (c) 2017, 2023 Contributors to the Eclipse Foundation
//

== Entity Operations [[a1060]]

This chapter describes the use of the
`EntityManager` API to manage the entity instance lifecycle and the use
of the `Query` API to retrieve and query entities and their persistent
state.

=== EntityManager [[a1062]]

An EntityManager instance is associated with
a persistence context. A persistence context is a set of entity
instances in which for any persistent entity identity there is a unique
entity instance. Within the persistence context, the entity instances
and their lifecycle are managed. The `EntityManager` interface defines
the methods that are used to interact with the persistence context. The
`EntityManager` API is used to create and remove persistent entity
instances, to find persistent entities by primary key, and to query over
persistent entities.

The set of entities that can be managed by a
given `EntityManager` instance is defined by a persistence unit. A
persistence unit defines the set of all classes that are related or
grouped by the application, and which must be colocated in their mapping
to a single database.

<<a1062>> defines the `EntityManager` interface. The entity
instance lifecycle is described in <<a1929>>. The
relationships between entity managers and persistence contexts are
described in <<a2027>> and in further detail in <<a11431>>.
<<a2052>> describes mechanisms for concurrency control and locking.
<<a2153>> describes entity listeners and lifecycle callback methods for
entities. <<a2366>> describes support for automatic use of Bean Validation.
<<a2397>> describes the use of
entity graphs to control the path and boundaries of find and query
operations. <<a2397>> describes mechanisms for defining conversions between entity
and database representations for attributes of basic types. <<a3061>> describes mechanisms for
portable second-level cache configuration. The `Query`, `TypedQuery`,
`StoredProcedureQuery`, and related interfaces are described in <<a3125>>. <<a4639>> provides a
summary of exceptions. The Jakarta Persistence query language is defined in <<a4665>> and the APIs for
the construction of Criteria queries in <<a6925>>. The definition of
persistence units is described in <<a12229>>.

==== EntityManager Interface [[a1066]]

[source,java]
----
package jakarta.persistence;

import java.util.Map;
import java.util.List;
import jakarta.persistence.metamodel.Metamodel;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.CriteriaUpdate;
import jakarta.persistence.criteria.CriteriaDelete;

/**
 * Interface used to interact with the persistence context.
 *
 * <p> An <code>EntityManager</code> instance is associated with
 * a persistence context. A persistence context is a set of entity
 * instances in which for any persistent entity identity there is
 * a unique entity instance. Within the persistence context, the
 * entity instances and their lifecycle are managed.
 * The <code>EntityManager</code> API is used
 * to create and remove persistent entity instances, to find entities
 * by their primary key, and to query over entities.
 *
 * <p> The set of entities that can be managed by a given
 * <code>EntityManager</code> instance is defined by a persistence
 * unit. A persistence unit defines the set of all classes that are
 * related or grouped by the application, and which must be
 * colocated in their mapping to a single database.
 *
 * @see Query
 * @see TypedQuery
 * @see CriteriaQuery
 * @see PersistenceContext
 * @see StoredProcedureQuery
 *
 * @since 1.0
 */
public interface EntityManager extends AutoCloseable {

    /**
     * Make an instance managed and persistent.
     * @param entity  entity instance
     * @throws EntityExistsException if the entity already exists.
     * (If the entity already exists, the <code>EntityExistsException</code> may
     * be thrown when the persist operation is invoked, or the
     * <code>EntityExistsException</code> or another <code>PersistenceException</code> may be
     * thrown at flush or commit time.)
     * @throws IllegalArgumentException if the instance is not an
     *         entity
     * @throws TransactionRequiredException if there is no transaction when
     *         invoked on a container-managed entity manager of that is of type
     *         <code>PersistenceContextType.TRANSACTION</code>
     */
    public void persist(Object entity);

    /**
     * Merge the state of the given entity into the
     * current persistence context.
     * @param entity  entity instance
     * @return the managed instance that the state was merged to
     * @throws IllegalArgumentException if instance is not an
     *         entity or is a removed entity
     * @throws TransactionRequiredException if there is no transaction when
     *         invoked on a container-managed entity manager of that is of type
     *         <code>PersistenceContextType.TRANSACTION</code>
     */
    public <T> T merge(T entity);

    /**
     * Remove the entity instance.
     * @param entity  entity instance
     * @throws IllegalArgumentException if the instance is not an
     *         entity or is a detached entity
     * @throws TransactionRequiredException if invoked on a
     *         container-managed entity manager of type
     *         <code>PersistenceContextType.TRANSACTION</code> and there is
     *         no transaction
     */
    public void remove(Object entity);

    /**
     * Find by primary key.
     * Search for an entity of the specified class and primary key.
     * If the entity instance is contained in the persistence context,
     * it is returned from there.
     * @param entityClass  entity class
     * @param primaryKey  primary key
     * @return the found entity instance or null if the entity does
     *         not exist
     * @throws IllegalArgumentException if the first argument does
     *         not denote an entity type or the second argument is
     *         is not a valid type for that entity's primary key or
     *         is null
     */
    public <T> T find(Class<T> entityClass, Object primaryKey);

    /**
     * Find by primary key, using the specified properties.
     * Search for an entity of the specified class and primary key.
     * If the entity instance is contained in the persistence
     * context, it is returned from there.
     * If a vendor-specific property or hint is not recognized,
     * it is silently ignored.
     * @param entityClass  entity class
     * @param primaryKey   primary key
     * @param properties  standard and vendor-specific properties
     *        and hints
     * @return the found entity instance or null if the entity does
     *         not exist
     * @throws IllegalArgumentException if the first argument does
     *         not denote an entity type or the second argument is
     *         is not a valid type for that entity's primary key or
     *         is null
     * @since 2.0
     */
    public <T> T find(Class<T> entityClass, Object primaryKey,
                      Map<String, Object> properties);

    /**
     * Find by primary key and lock.
     * Search for an entity of the specified class and primary key
     * and lock it with respect to the specified lock type.
     * If the entity instance is contained in the persistence context,
     * it is returned from there, and the effect of this method is
     * the same as if the lock method had been called on the entity.
     * <p> If the entity is found within the persistence context and the
     * lock mode type is pessimistic and the entity has a version
     * attribute, the persistence provider must perform optimistic
     * version checks when obtaining the database lock.  If these
     * checks fail, the <code>OptimisticLockException</code> will be thrown.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the database
     *    locking failure causes only statement-level rollback
     * </ul>
     * @param entityClass  entity class
     * @param primaryKey  primary key
     * @param lockMode  lock mode
     * @return the found entity instance or null if the entity does
     *         not exist
     * @throws IllegalArgumentException if the first argument does
     *         not denote an entity type or the second argument is
     *         not a valid type for that entity's primary key or
     *         is null
     * @throws TransactionRequiredException if there is no
     *         transaction and a lock mode other than <code>NONE</code> is
     *         specified or if invoked on an entity manager which has
     *         not been joined to the current transaction and a lock
     *         mode other than <code>NONE</code> is specified
     * @throws OptimisticLockException if the optimistic version
     *         check fails
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     * @since 2.0
     */
    public <T> T find(Class<T> entityClass, Object primaryKey,
                      LockModeType lockMode);

    /**
     * Find by primary key and lock, using the specified properties.
     * Search for an entity of the specified class and primary key
     * and lock it with respect to the specified lock type.
     * If the entity instance is contained in the persistence context,
     * it is returned from there.
     * <p> If the entity is found
     * within the persistence context and the lock mode type
     * is pessimistic and the entity has a version attribute, the
     * persistence provider must perform optimistic version checks
     * when obtaining the database lock.  If these checks fail,
     * the <code>OptimisticLockException</code> will be thrown.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the database
     *    locking failure causes only statement-level rollback
     * </ul>
     * <p>If a vendor-specific property or hint is not recognized,
     * it is silently ignored.
     * <p>Portable applications should not rely on the standard timeout
     * hint. Depending on the database in use and the locking
     * mechanisms used by the provider, the hint may or may not
     * be observed.
     * @param entityClass  entity class
     * @param primaryKey  primary key
     * @param lockMode  lock mode
     * @param properties  standard and vendor-specific properties
     *        and hints
     * @return the found entity instance or null if the entity does
     *         not exist
     * @throws IllegalArgumentException if the first argument does
     *         not denote an entity type or the second argument is
     *         not a valid type for that entity's primary key or
     *         is null
     * @throws TransactionRequiredException if there is no
     *         transaction and a lock mode other than <code>NONE</code> is
     *         specified or if invoked on an entity manager which has
     *         not been joined to the current transaction and a lock
     *         mode other than <code>NONE</code> is specified
     * @throws OptimisticLockException if the optimistic version
     *         check fails
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     * @since 2.0
     */
    public <T> T find(Class<T> entityClass, Object primaryKey,
                      LockModeType lockMode,
                      Map<String, Object> properties);

    /**
     * Find an instance of the given entity class by primary key,
     * using the specified {@linkplain FindOption options}.
     * Search for an entity with the specified class and primary key.
     * If the given options include a {@link LockModeType}, lock it
     * with respect to the specified lock type.
     * If the entity instance is contained in the persistence context,
     * it is returned from there.
     * <p>If the entity is found within the persistence context and
     * the lock mode type is pessimistic and the entity has a version
     * attribute, the persistence provider must perform optimistic
     * version checks when obtaining the database lock.  If these checks
     * fail, the <code>OptimisticLockException</code> will be thrown.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown
     *      if the database locking failure causes transaction-level
     *      rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if
     *      the database locking failure causes only statement-level
     *      rollback
     * </ul>
     * <p>If a vendor-specific {@linkplain FindOption option} is not
     * recognized, it is silently ignored.
     * <p>Portable applications should not rely on the standard
     * {@linkplain Timeout timeout option}. Depending on the database
     * in use and the locking mechanisms used by the provider, this
     * option may or may not be observed.
     * @param entityClass  entity class
     * @param primaryKey  primary key
     * @param options  standard and vendor-specific options
     * @return the found entity instance or null if the entity does
     *         not exist
     * @throws IllegalArgumentException if there are contradictory
     *         options, if the first argument does not denote an entity
     *         type belonging to the persistence unit, or if the second
     *         argument is not a valid non-null instance of the entity
     *         primary key type
     * @throws TransactionRequiredException if there is no transaction
     *         and a lock mode other than <code>NONE</code> is
     *         specified or if invoked on an entity manager which has
     *         not been joined to the current transaction and a lock
     *         mode other than <code>NONE</code> is specified
     * @throws OptimisticLockException if the optimistic version check
     *         fails
     * @throws PessimisticLockException if pessimistic locking fails
     *         and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call is made
     * @since 3.2
     */
    public <T> T find(Class<T> entityClass, Object primaryKey,
                      FindOption... options);

    /**
     * Find an instance of the root entity of the given {@link EntityGraph}
     * by primary key, using the specified {@linkplain FindOption options},
     * and interpreting the {@code EntityGraph} as a load graph.
     * Search for an entity with the specified type and primary key.
     * If the given options include a {@link LockModeType}, lock it
     * with respect to the specified lock type.
     * If the entity instance is contained in the persistence context,
     * it is returned from there.
     * <p> If the entity is found within the persistence context and
     * the lock mode type is pessimistic and the entity has a version
     * attribute, the persistence provider must perform optimistic
     * version checks when obtaining the database lock.  If these checks
     * fail, the <code>OptimisticLockException</code> will be thrown.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown
     *      if the database locking failure causes transaction-level
     *      rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if
     *      the database locking failure causes only statement-level
     *      rollback
     * </ul>
     * <p>If a vendor-specific {@linkplain FindOption option} is not
     * recognized, it is silently ignored.
     * <p>Portable applications should not rely on the standard
     * {@linkplain Timeout timeout option}. Depending on the database
     * in use and the locking mechanisms used by the provider, this
     * option may or may not be observed.
     * @param entityGraph  entity graph interpreted as a load graph
     * @param primaryKey  primary key
     * @param options  standard and vendor-specific options
     * @return the found entity instance or null if the entity does
     *         not exist
     * @throws IllegalArgumentException if there are contradictory
     *         options, if the first argument does not denote an entity
     *         type belonging to the persistence unit, or if the second
     *         argument is not a valid non-null instance of the entity
     *         primary key type
     * @throws TransactionRequiredException if there is no transaction
     *         and a lock mode other than <code>NONE</code> is
     *         specified or if invoked on an entity manager which has
     *         not been joined to the current transaction and a lock
     *         mode other than <code>NONE</code> is specified
     * @throws OptimisticLockException if the optimistic version check
     *         fails
     * @throws PessimisticLockException if pessimistic locking fails
     *         and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call is made
     * @since 3.2
     */
    public <T> T find(EntityGraph<T> entityGraph, Object primaryKey,
                      FindOption... options);

    /**
     * Obtain a reference to an instance of the given entity class
     * with the given primary key, whose state may be lazily fetched.
     * <p>If the requested instance does not exist in the database,
     * the <code>EntityNotFoundException</code> is thrown when the
     * instance state is first accessed.
     * (The persistence provider runtime is permitted but not
     * required to throw the <code>EntityNotFoundException</code>
     * when <code>getReference</code> is called.)
     * <p>The application should not expect the instance state to
     * be available upon detachment, unless it was accessed by the
     * application while the entity manager was open.
     * @param entityClass  entity class
     * @param primaryKey  primary key
     * @return a reference to the entity instance
     * @throws IllegalArgumentException if the first argument does
     *         not denote an entity type or the second argument is
     *         not a valid type for that entity's primary key or
     *         is null
     * @throws EntityNotFoundException if the entity state cannot
     *         be accessed
     */
    public <T> T getReference(Class<T> entityClass, Object primaryKey);

    /**
     * Obtain a reference to an instance of the entity class of the
     * given object, with the same primary key as the given object,
     * whose state may be lazily fetched. The given object may be
     * persistent or detached, but may be neither new nor removed.
     * <p>If the requested instance does not exist in the database,
     * the <code>EntityNotFoundException</code> is thrown when the
     * instance state is first accessed.
     * (The persistence provider runtime is permitted but not
     * required to throw the <code>EntityNotFoundException</code>
     * when <code>getReference</code> is called.)
     * <p>The application should not expect the instance state to
     * be available upon detachment, unless it was accessed by the
     * application while the entity manager was open.
     * @param entity  a persistent or detached entity instance
     * @return a reference to the entity instance
     * @throws IllegalArgumentException if the given object is not
     *         an entity, or if it is neither persistent nor detached
     * @throws EntityNotFoundException if the entity state cannot be
     *         accessed
     */
    public <T> T getReference(T entity);

    /**
     * Synchronize the persistence context to the
     * underlying database.
     * @throws TransactionRequiredException if there is
     *         no transaction or if the entity manager has not been
     *         joined to the current transaction
     * @throws PersistenceException if the flush fails
     */
    public void flush();

    /**
     * Set the flush mode that applies to all objects contained
     * in the persistence context.
     * @param flushMode  flush mode
     */
    public void setFlushMode(FlushModeType flushMode);

    /**
     * Get the flush mode that applies to all objects contained
     * in the persistence context.
     * @return flushMode
     */
    public FlushModeType getFlushMode();

    /**
     * Lock an entity instance that is contained in the persistence
     * context with the specified lock mode type.
     * <p>If a pessimistic lock mode type is specified and the entity
     * contains a version attribute, the persistence provider must
     * also perform optimistic version checks when obtaining the
     * database lock.  If these checks fail, the
     * <code>OptimisticLockException</code> will be thrown.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the database
     *    locking failure causes only statement-level rollback
     * </ul>
     * @param entity  entity instance
     * @param lockMode  lock mode
     * @throws IllegalArgumentException if the instance is not an
     *         entity or is a detached entity
     * @throws TransactionRequiredException if there is no
     *         transaction or if invoked on an entity manager which
     *         has not been joined to the current transaction
     * @throws EntityNotFoundException if the entity does not exist
     *         in the database when pessimistic locking is
     *         performed
     * @throws OptimisticLockException if the optimistic version
     *         check fails
     * @throws PessimisticLockException if pessimistic locking fails
     *         and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     */
    public void lock(Object entity, LockModeType lockMode);

    /**
     * Lock an entity instance that is contained in the persistence
     * context with the specified lock mode type and with specified
     * properties.
     * <p>If a pessimistic lock mode type is specified and the entity
     * contains a version attribute, the persistence provider must
     * also perform optimistic version checks when obtaining the
     * database lock.  If these checks fail, the
     * <code>OptimisticLockException</code> will be thrown.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the database
     *    locking failure causes only statement-level rollback
     * </ul>
     * <p>If a vendor-specific property or hint is not recognized,
     * it is silently ignored.
     * <p>Portable applications should not rely on the standard timeout
     * hint. Depending on the database in use and the locking
     * mechanisms used by the provider, the hint may or may not
     * be observed.
     * @param entity  entity instance
     * @param lockMode  lock mode
     * @param properties  standard and vendor-specific properties
     *        and hints
     * @throws IllegalArgumentException if the instance is not an
     *         entity or is a detached entity
     * @throws TransactionRequiredException if there is no
     *         transaction or if invoked on an entity manager which
     *         has not been joined to the current transaction
     * @throws EntityNotFoundException if the entity does not exist
     *         in the database when pessimistic locking is
     *         performed
     * @throws OptimisticLockException if the optimistic version
     *         check fails
     * @throws PessimisticLockException if pessimistic locking fails
     *         and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     * @since 2.0
     */
    public void lock(Object entity, LockModeType lockMode,
                     Map<String, Object> properties);

    /**
     * Lock an entity instance that is contained in the persistence
     * context with the specified lock mode type, using specified
     * {@linkplain LockOption options}.
     * <p>If a pessimistic lock mode type is specified and the entity
     * contains a version attribute, the persistence provider must
     * also perform optimistic version checks when obtaining the
     * database lock.  If these checks fail, the
     * <code>OptimisticLockException</code> will be thrown.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown
     *      if the database locking failure causes transaction-level
     *      rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if
     *      the database locking failure causes only statement-level
     *      rollback
     * </ul>
     * <p>If a vendor-specific {@link LockOption} is not recognized,
     * it is silently ignored.
     * <p>Portable applications should not rely on the standard
     * {@linkplain Timeout timeout option}. Depending on the database
     * in use and the locking mechanisms used by the provider, the
     * option may or may not be observed.
     * @param entity  entity instance
     * @param lockMode  lock mode
     * @param options  standard and vendor-specific options
     * @throws IllegalArgumentException if the instance is not an
     *         entity or is a detached entity
     * @throws TransactionRequiredException if there is no
     *         transaction or if invoked on an entity manager which
     *         has not been joined to the current transaction
     * @throws EntityNotFoundException if the entity does not exist
     *         in the database when pessimistic locking is
     *         performed
     * @throws OptimisticLockException if the optimistic version
     *         check fails
     * @throws PessimisticLockException if pessimistic locking fails
     *         and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call is made
     * @since 3.2
     */
    public void lock(Object entity, LockModeType lockMode,
                     LockOption... options);

    /**
     * Refresh the state of the instance from the database,
     * overwriting changes made to the entity, if any.
     * @param entity  entity instance
     * @throws IllegalArgumentException if the instance is not
     *         an entity or the entity is not managed
     * @throws TransactionRequiredException if there is no
     *         transaction when invoked on a container-managed
     *         entity manager of type <code>PersistenceContextType.TRANSACTION</code>
     * @throws EntityNotFoundException if the entity no longer
     *         exists in the database
     */
    public void refresh(Object entity);

    /**
     * Refresh the state of the instance from the database, using
     * the specified properties, and overwriting changes made to
     * the entity, if any.
     * <p> If a vendor-specific property or hint is not recognized,
     * it is silently ignored.
     * @param entity  entity instance
     * @param properties  standard and vendor-specific properties
     *        and hints
     * @throws IllegalArgumentException if the instance is not
     *         an entity or the entity is not managed
     * @throws TransactionRequiredException if there is no
     *         transaction when invoked on a container-managed
     *         entity manager of type <code>PersistenceContextType.TRANSACTION</code>
     * @throws EntityNotFoundException if the entity no longer
     *         exists in the database
     * @since 2.0
     */
    public void refresh(Object entity,
                        Map<String, Object> properties);

    /**
     * Refresh the state of the instance from the database,
     * overwriting changes made to the entity, if any, and
     * lock it with respect to given lock mode type.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the
     *    database locking failure causes only statement-level
     *    rollback.
     * </ul>
     * @param entity  entity instance
     * @param lockMode  lock mode
     * @throws IllegalArgumentException if the instance is not
     *         an entity or the entity is not managed
     * @throws TransactionRequiredException if invoked on a
     *         container-managed entity manager of type
     *         <code>PersistenceContextType.TRANSACTION</code> when there is
     *         no transaction; if invoked on an extended entity manager when
     *         there is no transaction and a lock mode other than <code>NONE</code>
     *         has been specified; or if invoked on an extended entity manager
     *         that has not been joined to the current transaction and a
     *         lock mode other than <code>NONE</code> has been specified
     * @throws EntityNotFoundException if the entity no longer exists
     *         in the database
     * @throws PessimisticLockException if pessimistic locking fails
     *         and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     * @since 2.0
     */
    public void refresh(Object entity, LockModeType lockMode);

    /**
     * Refresh the state of the instance from the database,
     * overwriting changes made to the entity, if any, and
     * lock it with respect to given lock mode type and with
     * specified properties.
     * <p>If the lock mode type is pessimistic and the entity instance
     * is found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if the database
     *    locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the database
     *    locking failure causes only statement-level rollback
     * </ul>
     * <p>If a vendor-specific property or hint is not recognized,
     *    it is silently ignored.
     * <p>Portable applications should not rely on the standard timeout
     * hint. Depending on the database in use and the locking
     * mechanisms used by the provider, the hint may or may not
     * be observed.
     * @param entity  entity instance
     * @param lockMode  lock mode
     * @param properties  standard and vendor-specific properties
     *        and hints
     * @throws IllegalArgumentException if the instance is not
     *         an entity or the entity is not managed
     * @throws TransactionRequiredException if invoked on a
     *         container-managed entity manager of type
     *         <code>PersistenceContextType.TRANSACTION</code> when there is
     *         no transaction; if invoked on an extended entity manager when
     *         there is no transaction and a lock mode other than <code>NONE</code>
     *         has been specified; or if invoked on an extended entity manager
     *         that has not been joined to the current transaction and a
     *         lock mode other than <code>NONE</code> has been specified
     * @throws EntityNotFoundException if the entity no longer exists
     *         in the database
     * @throws PessimisticLockException if pessimistic locking fails
     *         and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and
     *         only the statement is rolled back
     * @throws PersistenceException if an unsupported lock call
     *         is made
     * @since 2.0
     */
    public void refresh(Object entity, LockModeType lockMode,
                        Map<String, Object> properties);

    /**
     * Refresh the state of the given entity instance from the
     * database, using the specified {@linkplain RefreshOption options},
     * overwriting changes made to the entity, if any. If the supplied
     * options include a {@link LockModeType}, lock the given entity with
     * respect to the specified lock type.
     * <p>If the lock mode type is pessimistic and the entity instance is
     * found but cannot be locked:
     * <ul>
     * <li> the <code>PessimisticLockException</code> will be thrown if
     *      the database locking failure causes transaction-level rollback
     * <li> the <code>LockTimeoutException</code> will be thrown if the
     *      database locking failure causes only statement-level rollback
     * </ul>
     * <p>If a vendor-specific {@link RefreshOption} is not recognized,
     * it is silently ignored.
     * <p>Portable applications should not rely on the standard
     * {@linkplain Timeout timeout option}. Depending on the database in
     * use and the locking mechanisms used by the provider, the hint may
     * or may not be observed.
     * @param entity  entity instance
     * @param options  standard and vendor-specific options
     * @throws IllegalArgumentException if the instance is not an entity
     *         or the entity is not managed
     * @throws TransactionRequiredException if invoked on a
     *         container-managed entity manager of type
     *         <code>PersistenceContextType.TRANSACTION</code> when there
     *         is no transaction; if invoked on an extended entity manager
     *         when there is no transaction and a lock mode other than
     *         <code>NONE</code> has been specified; or if invoked on an
     *         extended entity manager that has not been joined to the
     *         current transaction and a lock mode other than
     *         <code>NONE</code> has been specified
     * @throws EntityNotFoundException if the entity no longer exists in
     *         the database
     * @throws PessimisticLockException if pessimistic locking fails and
     *         the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking fails and only
     *         the statement is rolled back
     * @throws PersistenceException if an unsupported lock call is made
     * @since 3.2
     */
    public void refresh(Object entity,
                        RefreshOption... options);

    /**
     * Clear the persistence context, causing all managed
     * entities to become detached. Changes made to entities that
     * have not been flushed to the database will not be
     * persisted.
     */
    public void clear();

    /**
     * Remove the given entity from the persistence context, causing
     * a managed entity to become detached.  Unflushed changes made
     * to the entity if any (including removal of the entity),
     * will not be synchronized to the database.  Entities which
     * previously referenced the detached entity will continue to
     * reference it.
     * @param entity  entity instance
     * @throws IllegalArgumentException if the instance is not an
     *         entity
     * @since 2.0
     */
    public void detach(Object entity);

    /**
     * Check if the instance is a managed entity instance belonging
     * to the current persistence context.
     * @param entity  entity instance
     * @return boolean indicating if entity is in persistence context
     * @throws IllegalArgumentException if not an entity
     */
    public boolean contains(Object entity);

    /**
     * Get the current lock mode for the entity instance.
     * @param entity  entity instance
     * @return lock mode
     * @throws TransactionRequiredException if there is no
     *         transaction or if the entity manager has not been
     *         joined to the current transaction
     * @throws IllegalArgumentException if the instance is not a
     *         managed entity and a transaction is active
     * @since 2.0
     */
    public LockModeType getLockMode(Object entity);

    /**
     * Set the cache retrieval mode that is in effect during
     * query execution. This cache retrieval mode overrides the
     * cache retrieve mode in use by the entity manager.
     * @param cacheRetrieveMode cache retrieval mode
     * @since 3.2
     */
    public void setCacheRetrieveMode(CacheRetrieveMode cacheRetrieveMode);

    /**
     * Set the default cache storage mode for this persistence context.
     * @param cacheStoreMode cache storage mode
     * @since 3.2
     */
    public void setCacheStoreMode(CacheStoreMode cacheStoreMode);

    /**
     * The cache retrieval mode for this persistence context.
     * @since 3.2
     */
    public CacheRetrieveMode getCacheRetrieveMode();

    /**
     * The cache storage mode for this persistence context.
     * @since 3.2
     */
    public CacheStoreMode getCacheStoreMode();

    /**
     * Set an entity manager property or hint.
     * If a vendor-specific property or hint is not recognized, it is
     * silently ignored.
     * @param propertyName name of property or hint
     * @param value  value for property or hint
     * @throws IllegalArgumentException if the second argument is
     *         not valid for the implementation
     * @since 2.0
     */
    public void setProperty(String propertyName, Object value);

    /**
     * Get the properties and hints and associated values that are in effect
     * for the entity manager. Changing the contents of the map does
     * not change the configuration in effect.
     * @return map of properties and hints in effect for entity manager
     * @since 2.0
     */
    public Map<String, Object> getProperties();

    /**
     * Create an instance of <code>Query</code> for executing a
     * Jakarta Persistence query language statement.
     * @param qlString a Jakarta Persistence query string
     * @return the new query instance
     * @throws IllegalArgumentException if the query string is
     *         found to be invalid
     */
    public Query createQuery(String qlString);

    /**
     * Create an instance of <code>TypedQuery</code> for executing a
     * criteria query.
     * @param criteriaQuery  a criteria query object
     * @return the new query instance
     * @throws IllegalArgumentException if the criteria query is
     *         found to be invalid
     * @since 2.0
     */
    public <T> TypedQuery<T> createQuery(CriteriaQuery<T> criteriaQuery);

    /**
     * Create an instance of <code>TypedQuery</code> for executing a
     * criteria query, which may be a union or intersection of
     * top-level queries.
     * @param criteriaQuery  a criteria query object
     * @return the new query instance
     * @throws IllegalArgumentException if the criteria query is
     *         found to be invalid
     * @since 3.2
     */
    <T> TypedQuery<T> createQuery(CriteriaSelect<T> criteriaQuery);

    /**
     * Create an instance of <code>Query</code> for executing a criteria
     * update query.
     * @param updateQuery  a criteria update query object
     * @return the new query instance
     * @throws IllegalArgumentException if the update query is
     *         found to be invalid
     * @since 2.1
     */
    public Query createQuery(CriteriaUpdate updateQuery);

    /**
     * Create an instance of <code>Query</code> for executing a criteria
     * delete query.
     * @param deleteQuery  a criteria delete query object
     * @return the new query instance
     * @throws IllegalArgumentException if the delete query is
     *         found to be invalid
     * @since 2.1
     */
    public Query createQuery(CriteriaDelete deleteQuery);

    /**
     * Create an instance of <code>TypedQuery</code> for executing a
     * Jakarta Persistence query language statement.
     * The select list of the query must contain only a single
     * item, which must be assignable to the type specified by
     * the <code>resultClass</code> argument.
     * @param qlString a Jakarta Persistence query string
     * @param resultClass the type of the query result
     * @return the new query instance
     * @throws IllegalArgumentException if the query string is found
     *         to be invalid or if the query result is found to
     *         not be assignable to the specified type
     * @since 2.0
     */
    public <T> TypedQuery<T> createQuery(String qlString, Class<T> resultClass);

    /**
     * Create an instance of <code>Query</code> for executing a named query
     * (in the Jakarta Persistence query language or in native SQL).
     * @param name the name of a query defined in metadata
     * @return the new query instance
     * @throws IllegalArgumentException if a query has not been
     *         defined with the given name or if the query string is
     *         found to be invalid
     */
    public Query createNamedQuery(String name);

    /**
     * Create an instance of <code>TypedQuery</code> for executing a
     * Jakarta Persistence query language named query.
     * The select list of the query must contain only a single
     * item, which must be assignable to the type specified by
     * the <code>resultClass</code> argument.
     * @param name the name of a query defined in metadata
     * @param resultClass the type of the query result
     * @return the new query instance
     * @throws IllegalArgumentException if a query has not been
     *         defined with the given name or if the query string is
     *         found to be invalid or if the query result is found to
     *         not be assignable to the specified type
     * @since 2.0
     */
    public <T> TypedQuery<T> createNamedQuery(String name, Class<T> resultClass);

    /**
     * Create an instance of <code>Query</code> for executing
     * a native SQL statement, e.g., for update or delete.
     * If the query is not an update or delete query, query
     * execution will result in each row of the SQL result
     * being returned as a result of type Object[] (or a result
     * of type Object if there is only one column in the select
     * list.)  Column values are returned in the order of their
     * appearance in the select list and default JDBC type
     * mappings are applied.
     * @param sqlString a native SQL query string
     * @return the new query instance
     */
    public Query createNativeQuery(String sqlString);

    /**
     * Create an instance of <code>Query</code> for executing
     * a native SQL query.
     * @param sqlString a native SQL query string
     * @param resultClass the class of the resulting instance(s)
     * @return the new query instance
     */
    public Query createNativeQuery(String sqlString, Class resultClass);

    /**
     * Create an instance of <code>Query</code> for executing
     * a native SQL query.
     * @param sqlString a native SQL query string
     * @param resultSetMapping the name of the result set mapping
     * @return the new query instance
     */
    public Query createNativeQuery(String sqlString, String resultSetMapping);

    /**
     * Create an instance of <code>StoredProcedureQuery</code> for executing a
     * stored procedure in the database.
     * <p>Parameters must be registered before the stored procedure can
     * be executed.
     * <p>If the stored procedure returns one or more result sets,
     * any result set will be returned as a list of type Object[].
     * @param name name assigned to the stored procedure query
     * in metadata
     * @return the new stored procedure query instance
     * @throws IllegalArgumentException if a query has not been
     * defined with the given name
     * @since 2.1
     */
    public StoredProcedureQuery createNamedStoredProcedureQuery(String name);

    /**
     * Create an instance of <code>StoredProcedureQuery</code> for executing a
     * stored procedure in the database.
     * <p>Parameters must be registered before the stored procedure can
     * be executed.
     * <p>If the stored procedure returns one or more result sets,
     * any result set will be returned as a list of type Object[].
     * @param procedureName name of the stored procedure in the
     * database
     * @return the new stored procedure query instance
     * @throws IllegalArgumentException if a stored procedure of the
     * given name does not exist (or the query execution will
     * fail)
     * @since 2.1
     */
    public StoredProcedureQuery createStoredProcedureQuery(String procedureName);

    /**
     * Create an instance of <code>StoredProcedureQuery</code> for executing a
     * stored procedure in the database.
     * <p>Parameters must be registered before the stored procedure can
     * be executed.
     * <p>The <code>resultClass</code> arguments must be specified in the order in
     * which the result sets will be returned by the stored procedure
     * invocation.
     * @param procedureName name of the stored procedure in the
     * database
     * @param resultClasses classes to which the result sets
     * produced by the stored procedure are to
     * be mapped
     * @return the new stored procedure query instance
     * @throws IllegalArgumentException if a stored procedure of the
     * given name does not exist (or the query execution will
     * fail)
     * @since 2.1
     */
    public StoredProcedureQuery createStoredProcedureQuery(
	       String procedureName, Class... resultClasses);

    /**
     * Create an instance of <code>StoredProcedureQuery</code> for executing a
     * stored procedure in the database.
     * <p>Parameters must be registered before the stored procedure can
     * be executed.
     * <p>The <code>resultSetMapping</code> arguments must be specified in the order
     * in which the result sets will be returned by the stored
     * procedure invocation.
     * @param procedureName name of the stored procedure in the
     *        database
     * @param resultSetMappings the names of the result set mappings
     *        to be used in mapping result sets
     *        returned by the stored procedure
     * @return the new stored procedure query instance
     * @throws IllegalArgumentException if a stored procedure or
     *         result set mapping of the given name does not exist
     *         (or the query execution will fail)
     */
    public StoredProcedureQuery createStoredProcedureQuery(
              String procedureName, String... resultSetMappings);

    /**
     * Indicate to the entity manager that a JTA transaction is
     * active and join the persistence context to it.
     * <p>This method should be called on a JTA application
     * managed entity manager that was created outside the scope
     * of the active transaction or on an entity manager of type
     * <code>SynchronizationType.UNSYNCHRONIZED</code> to associate
     * it with the current JTA transaction.
     * @throws TransactionRequiredException if there is
     *         no transaction
     */
    public void joinTransaction();

    /**
     * Determine whether the entity manager is joined to the
     * current transaction. Returns false if the entity manager
     * is not joined to the current transaction or if no
     * transaction is active
     * @return boolean
     * @since 2.1
     */
    public boolean isJoinedToTransaction();

    /**
     * Return an object of the specified type to allow access to the
     * provider-specific API.   If the provider's <code>EntityManager</code>
     * implementation does not support the specified class, the
     * <code>PersistenceException</code> is thrown.
     * @param cls  the class of the object to be returned.  This is
     * normally either the underlying <code>EntityManager</code> implementation
     * class or an interface that it implements.
     * @return an instance of the specified class
     * @throws PersistenceException if the provider does not
     *         support the call
     * @since 2.0
     */
    public <T> T unwrap(Class<T> cls);

    /**
     * Return the underlying provider object for the <code>EntityManager</code>,
     * if available. The result of this method is implementation
     * specific.
     * <p>The <code>unwrap</code> method is to be preferred for new applications.
     * @return underlying provider object for EntityManager
     */
    public Object getDelegate();

    /**
     * Close an application-managed entity manager.
     * After the close method has been invoked, all methods
     * on the <code>EntityManager</code> instance and any
     * <code>Query</code>, <code>TypedQuery</code>, and
     * <code>StoredProcedureQuery</code> objects obtained from
     * it will throw the <code>IllegalStateException</code>
     * except for <code>getProperties</code>,
     * <code>getTransaction</code>, and <code>isOpen</code> (which will return false).
     * If this method is called when the entity manager is
     * joined to an active transaction, the persistence
     * context remains managed until the transaction completes.
     * @throws IllegalStateException if the entity manager
     *         is container-managed
     */
    public void close();

    /**
     * Determine whether the entity manager is open.
     * @return true until the entity manager has been closed
     */
    public boolean isOpen();

    /**
     * Return the resource-level <code>EntityTransaction</code> object.
     * The <code>EntityTransaction</code> instance may be used serially to
     * begin and commit multiple transactions.
     * @return EntityTransaction instance
     * @throws IllegalStateException if invoked on a JTA
     *         entity manager
     */
    public EntityTransaction getTransaction();

    /**
     * Return the entity manager factory for the entity manager.
     * @return EntityManagerFactory instance
     * @throws IllegalStateException if the entity manager has
     *         been closed
     * @since 2.0
     */
    public EntityManagerFactory getEntityManagerFactory();

    /**
     * Return an instance of <code>CriteriaBuilder</code> for the creation of
     * <code>CriteriaQuery</code> objects.
     * @return CriteriaBuilder instance
     * @throws IllegalStateException if the entity manager has
     *         been closed
     * @since 2.0
     */
    public CriteriaBuilder getCriteriaBuilder();

    /**
     * Return an instance of <code>Metamodel</code> interface for access to the
     * metamodel of the persistence unit.
     * @return Metamodel instance
     * @throws IllegalStateException if the entity manager has
     *         been closed
     * @since 2.0
     */
    public Metamodel getMetamodel();

    /**
     * Return a mutable EntityGraph that can be used to dynamically create an
     * EntityGraph.
     * @param rootType class of entity graph
     * @return entity graph
     * @since 2.1
     */
    public <T> EntityGraph<T> createEntityGraph(Class<T> rootType);

    /**
     * Return a mutable copy of the named EntityGraph.  If there
     * is no entity graph with the specified name, null is returned.
     * @param graphName name of an entity graph
     * @return entity graph
     * @since 2.1
     */
    public EntityGraph<?> createEntityGraph(String graphName);

    /**
     * Return a named EntityGraph. The returned EntityGraph
     * should be considered immutable.
     * @param graphName  name of an existing entity graph
     * @return named entity graph
     * @throws IllegalArgumentException if there is no EntityGraph of
     *         the given name
     * @since 2.1
     */
    public  EntityGraph<?> getEntityGraph(String graphName);

    /**
     * Return all named EntityGraphs that have been defined for the provided
     * class type.
     * @param entityClass  entity class
     * @return list of all entity graphs defined for the entity
     * @throws IllegalArgumentException if the class is not an entity
     * @since 2.1
     */
    public <T> List<EntityGraph<? super T>> getEntityGraphs(Class<T> entityClass);

    /**
     * Execute the given action using the database connection underlying this
     * {@code EntityManager}. Usually, the connection is a JDBC connection, but a
     * provider might support some other native connection type, and is not required
     * to support {@code java.sql.Connection}. If this {@code EntityManager} is
     * associated with a transaction, the action is executed in the context of the
     * transaction. The given action should close any resources it creates, but should
     * not close the connection itself, nor commit or roll back the transaction. If
     * the given action throws an exception, the persistence provider must mark the
     * transaction for rollback.
     * @param action the action
     * @param <C> the connection type, usually {@code java.sql.Connection}
     * @throws PersistenceException wrapping the checked {@link Exception} thrown by
     *         {@link ConnectionConsumer#accept}, if any
     * @since 3.2
     */
    public <C> void runWithConnection(ConnectionConsumer<C> action);

    /**
     * Call the given function and return its result using the database connection
     * underlying this {@code EntityManager}. Usually, the connection is a JDBC
     * connection, but a provider might support some other native connection type,
     * and is not required to support {@code java.sql.Connection}. If this
     * {@code EntityManager} is associated with a transaction, the function is
     * executed in the context of the transaction. The given function should close
     * any resources it creates, but should not close the connection itself, nor
     * commit or roll back the transaction. If the given action throws an exception,
     * the persistence provider must mark the transaction for rollback.
     * @param function the function
     * @param <C> the connection type, usually {@code java.sql.Connection}
     * @param <T> the type of result returned by the function
     * @return the value returned by {@link ConnectionFunction#apply}.
     * @throws PersistenceException wrapping the checked {@link Exception} thrown by
     *         {@link ConnectionFunction#apply}, if any
     * @since 3.2
     */
    public <C,T> T callWithConnection(ConnectionFunction<C,T> function);

}
----

[NOTE]
====
The semantics of

    public <T> TypedQuery<T> createQuery(String qlString, Class<T> resultClass)

method may be extended in a future release of this specification to
support other result types. Applications that specify other result types
(e.g., Tuple.class) will not be portable.
====

[NOTE]
====
The semantics

    public <T> TypedQuery<T> createNamedQuery(String name, Class<T> resultClass)

method may be extended in a future release of this specification to
support other result types. Applications that specify other result types
(e.g., Tuple.class) will not be portable.
====

The `persist`, `merge`, `remove`, and
`refresh` methods must be invoked within a transaction context when an
entity manager with a transaction-scoped persistence context is used. If
there is no transaction context, the
`jakarta.persistence.TransactionRequiredException` is thrown.

Methods that specify a lock mode other than
`LockModeType.NONE` must be invoked within a transaction. If there is no
transaction or if the entity manager has not been joined to the
transaction, the `jakarta.persistence.TransactionRequiredException` is
thrown.

The `find` method (provided it is invoked
without a lock or invoked with `LockModeType.NONE`) and the
`getReference` method are not required to be invoked within a
transaction. If an entity manager with transaction-scoped persistence
context is in use, the resulting entities will be detached; if an entity
manager with an extended persistence context is used, they will be
managed. See <<a2027>> for entity manager use outside a
transaction.

The `Query`, `TypedQuery`,
`StoredProcedureQuery`, `CriteriaBuilder`, `Metamodel`, and
`EntityTransaction` objects obtained from an entity manager are valid
while that entity manager is open.

If the argument to the `createQuery` method
is not a valid Jakarta Persistence query string or a valid `CriteriaQuery`
object, the `IllegalArgumentException` may be thrown or the query
execution will fail and a `PersistenceException` will be thrown. If the
result class specification of a Jakarta Persistence query language query is
incompatible with the result of the query, the
`IllegalArgumentException` may be thrown when the `createQuery` method
is invoked or the query execution will fail and a `PersistenceException`
will be thrown when the query is executed. If a native query is not a
valid query for the database in use or if the result set specification
is incompatible with the result of the query, the query execution will
fail and a `PersistenceException` will be thrown when the query is
executed. The `PersistenceException` should wrap the underlying database
exception when possible.

Runtime exceptions thrown by the methods of
the `EntityManager` interface other than the `LockTimeoutException` will
cause the current transaction to be marked for rollback if the
persistence context is joined to that transaction.

The methods `close`, `isOpen`,
`joinTransaction`, and `getTransaction` are used to manage
application-managed entity managers and their lifecycle. See <<a11465>>.

The `EntityManager` interface and other
interfaces defined by this specification contain methods that take
properties and/or hints as arguments. This specification distinguishes
between `properties` and `hints` as follows:

* A property defined by this specification must
be observed by the provider unless otherwise explicitly stated.

* A hint specifies a preference on the part of
the application. While a hint defined by this specification should be
observed by the provider if possible, a hint may or may not always be
observed. A portable application must not depend on the observance of a
hint.

For example:

[source,java]
----
@Stateless
public class OrderEntryBean implements OrderEntry {
    @PersistenceContext
    EntityManager em;

    public void enterOrder(int custID, Order newOrder) {
        Customer cust = em.find(Customer.class, custID);
        cust.getOrders().add(newOrder);
        newOrder.setCustomer(cust);
        em.persist(newOrder);
    }
}
----

=== Entity Instance's Life Cycle [[a1929]]

This section describes the `EntityManager`
operations for managing an entity instance's lifecycle. An entity
instance can be characterized as being new, managed, detached, or
removed.

* A new entity instance has no persistent
identity, and is not yet associated with a persistence context.
* A managed entity instance is an instance with
a persistent identity that is currently associated with a persistence
context.
* A detached entity instance is an instance
with a persistent identity that is not (or no longer) associated with a
persistence context.
* A removed entity instance is an instance with
a persistent identity, associated with a persistence context, that will
be removed from the database upon transaction commit.

The following subsections describe the effect
of lifecycle operations upon entities. Use of the `cascade` annotation
element may be used to propagate the effect of an operation to
associated entities. The cascade functionality is most typically used in
parent-child relationships.

==== Entity Instance Creation

Entity instances are created by means of the
`new` operation. An entity instance, when first created by `new` is not
yet persistent. An instance becomes persistent by means of the
`EntityManager` API.

==== Persisting an Entity Instance

A new entity instance becomes both managed
and persistent by invoking the `persist` method on it or by cascading
the persist operation.

The semantics of the persist operation,
applied to an entity `X` are as follows:

* If X is a new entity, it becomes managed. The
entity X will be entered into the database at or before transaction
commit or as a result of the flush operation.
* If X is a preexisting managed entity, it is
ignored by the persist operation. However, the persist operation is
cascaded to entities referenced by X, if the relationships from X to
these other entities are annotated with the `cascade=PERSIST` or
`cascade=ALL` annotation element value or specified with the equivalent
XML descriptor element.
* If X is a removed entity, it becomes managed.
* If X is a detached object, the
`EntityExistsException` may be thrown when the persist operation is
invoked, or the `EntityExistsException` or another
`PersistenceException` `may` be thrown at flush or commit time.
* For all entities Y referenced by a
relationship from X, if the relationship to Y has been annotated with
the `cascade` element value `cascade=PERSIST` or `cascade=ALL`, the
persist operation is applied to Y.

==== Removal [[a1946]]

A managed entity instance becomes removed by
invoking the `remove` method on it or by cascading the remove operation.

The semantics of the remove operation,
applied to an entity X are as follows:

* If X is a new entity, it is ignored by the
remove operation. However, the remove operation is cascaded to entities
referenced by X, if the relationship from X to these other entities is
annotated with the `cascade=REMOVE` or `cascade=ALL` annotation element
value.
* If X is a managed entity, the remove
operation causes it to become removed. The remove operation is cascaded
to entities referenced by X, if the relationships from X to these other
entities is annotated with the `cascade=REMOVE` or `cascade=ALL`
annotation element value.
* If X is a detached entity, an
`IllegalArgumentException` will be thrown by the remove operation (or
the transaction commit will fail).
* If X is a removed entity, it is ignored by the remove operation.
* A removed entity X will be removed from the
database at or before transaction commit or as a result of the flush
operation.

After an entity has been removed, its state
(except for generated state) will be that of the entity at the point at
which the remove operation was called.

==== Synchronization to the Database [[a1955]]

In general, a persistence context will be
synchronized to the database as described below. However, a persistence
context of type `SynchronizationType.UNSYNCHRONIZED` or an
application-managed persistence context that has been created outside
the scope of the current transaction will only be synchronized to the
database if it has been joined to the current transaction by the
application's use of the `EntityManager` `joinTransaction` method.

The state of persistent entities is
synchronized to the database at transaction commit. This synchronization
involves writing to the database any updates to persistent entities and
their relationships as specified above.

An update to the state of an entity includes
both the assignment of a new value to a persistent property or field of
the entity as well as the modification of a mutable value of a
persistent property or fieldfootnote:[This includes, for
example. modifications to persistent attributes of type char[\] and
byte[\].].

Synchronization to the database does not
involve a refresh of any managed entities unless the `refresh` operation
is explicitly invoked on those entities or cascaded to them as a result
of the specification of the `cascade=REFRESH` or `cascade=ALL`
annotation element value.

Bidirectional relationships between
managed entities will be persisted based on references held by the
owning side of the relationship. It is the developer's responsibility to
keep the in-memory references held on the owning side and those held on
the inverse side consistent with each other when they change. In the
case of unidirectional one-to-one and one-to-many relationships, it is
the developer's responsibility to insure that the semantics of the
relationships are adhered to.footnote:[This might be an
issue if unique constraints (such as those described for the default
mappings in <<a640>> and <<a764>>) were not applied in the
definition of the object/relational mapping.]

[NOTE]
====
It is particularly important to ensure that
changes to the inverse side of a relationship result in appropriate
updates on the owning side, so as to ensure the changes are not lost
when they are synchronized to the database.
====

The persistence provider runtime is permitted
to perform synchronization to the database at other times as well when a
transaction is active and the persistence context is joined to the
transaction. The `flush` method can be used by the application to force
synchronization. It applies to entities associated with the persistence
context. The `setFlushMode` methods of the `EntityManager`, `Query`,
`TypedQuery`, and `StoredProcedureQuery` interfaces can be used to
control synchronization semantics. The effect of `FlushModeType.AUTO` is
defined in <<a4374>>. If `FlushModeType.COMMIT` is specified, flushing will occur at
transaction commit; the persistence provider is permitted, but not
required, to perform to flush at other times. If there is no transaction
active or if the persistence context has not been joined to the current
transaction, the persistence provider must not flush to the database.

The semantics of the flush operation, applied
to an entity `X` are as follows:

* If X is a managed entity, it is synchronized
to the database.
** For all entities Y referenced by a
relationship from X, if the relationship to Y has been annotated with
the `cascade` element value `cascade=PERSIST` or `cascade=ALL`, the
persist operation is applied to Y.
** For any entity Y referenced by a relationship
from X, where the relationship to Y has not been annotated with the
`cascade` element value `cascade=PERSIST` or `cascade=ALL`:
*** If Y is new or removed, an
`IllegalStateException` will be thrown by the flush operation (and the
transaction marked for rollback) or the transaction commit will fail.
*** If Y is detached, the semantics depend upon
the ownership of the relationship. If X owns the relationship, any
changes to the relationship are synchronized with the database;
otherwise, if Y owns the relationships, the behavior is undefined.
* If X is a removed entity, it is removed from
the database. No cascade options are relevant.

==== Refreshing an Entity Instance

The state of a managed entity instance is
refreshed from the database by invoking the `refresh` method on it or by
cascading the refresh operation.

The semantics of the refresh operation,
applied to an entity X are as follows:

* If X is a managed entity, the state of X is
refreshed from the database, overwriting changes made to the entity, if
any. The refresh operation is cascaded to entities referenced by X if
the relationship from X to these other entities is annotated with the
`cascade=REFRESH` or `cascade=ALL` annotation element value.
* If X is a new, detached, or removed entity,
the `IllegalArgumentException` is thrown.

==== Evicting an Entity Instance from the Persistence Context

An entity instance is removed from the
persistence context by invoking the `detach` method on it or cascading
the detach operation. Changes made to the entity, if any (including
removal of the entity), will not be synchronized to the database after
such eviction has taken place.

Applications must use the `flush` method
prior to the `detach` method to ensure portable semantics if changes
have been made to the entity (including removal of the entity). Because
the persistence provider may write to the database at times other than
the explicit invocation of the `flush` method, portable applications
must not assume that changes have not been written to the database if
the `flush` method has not been called prior to detach.

The semantics of the detach operation,
applied to an entity X are as follows:

* If X is a managed entity, the detach
operation causes it to become detached. The detach operation is cascaded
to entities referenced by X if the relationships from X to these other
entities is annotated with the `cascade=DETACH` or `cascade=ALL`
annotation element value. Entities which previously referenced X will
continue to reference X.
* If X is a new or detached entity, it is
ignored by the detach operation.
* If X is a removed entity, the detach
operation causes it to become detached. The detach operation is cascaded
to entities referenced by X if the relationships from X to these other
entities is annotated with the `cascade=DETACH` or `cascade=ALL`
annotation element value. Entities which previously referenced X will
continue to reference X. Portable applications should not pass removed
entities that have been detached from the persistence context to further
EntityManager operations.

==== Detached Entities [[a1982]]

A detached entity results from transaction
commit if a transaction-scoped persistence context is used (see <<a2027>>);
from transaction rollback (see <<a2049>>); from detaching
the entity from the persistence context; from clearing the persistence
context; from closing an entity manager; or from serializing an entity
or otherwise passing an entity by value—e.g., to a separate application
tier, through a remote interface, etc.

Detached entity instances continue to live
outside of the persistence context in which they were persisted or
retrieved. Their state is no longer guaranteed to be synchronized with
the database state.

The application may access the available
state of available detached entity instances after the persistence
context ends. The available state includes:

* Any persistent field or property not marked `fetch=LAZY`
* Any persistent field or property that was
accessed by the application or fetched by means of an entity graph

If the persistent field or property is an
association, the available state of an associated instance may only be
safely accessed if the associated instance is available. The available
instances include:

* Any entity instance retrieved using `find()`.
* Any entity instances retrieved using a query or explicitly requested in a fetch join.
* Any entity instance for which an instance
variable holding non-primary-key persistent state was accessed by the
application.
* Any entity instance that can be reached from
another available instance by navigating associations marked `fetch=EAGER`.

===== Merging Detached Entity State

The merge operation allows for the
propagation of state from detached entities onto persistent entities
managed by the entity manager.

The semantics of the merge operation applied
to an entity X are as follows:

* If X is a detached entity, the state of X is
copied onto a pre-existing managed entity instance X' of the same
identity or a new managed copy X' of X is created.
* If X is a new entity instance, a new managed
entity instance X' is created and the state of X is `copied` into the
new managed entity instance X'.
* If X is a removed entity instance, an
`IllegalArgumentException` will be thrown by the merge operation (or the
transaction commit will fail).
* If X is a managed entity, it is ignored by
the merge operation, however, the merge operation is cascaded to
entities referenced by relationships from X if these relationships have
been annotated with the `cascade` element value `cascade=MERGE` or
`cascade=ALL` annotation.
* For all entities Y referenced by
relationships from X having the `cascade` element value `cascade=MERGE`
or `cascade=ALL`, Y is merged recursively as Y'. For all such Y
referenced by X, X' is set to reference Y'. (Note that if X is managed
then X is the same object as X'.)
* If X is an entity merged to X', with a
reference to another entity Y, where `cascade=MERGE` or `cascade=ALL` is
not specified, then navigation of the same association from X' yields a
reference to a managed object Y' with the same persistent identity as Y.

The persistence provider must not merge
fields marked LAZY that have not been fetched: it must ignore such
fields when merging.

Any `Version` columns used by the entity must
be checked by the persistence runtime implementation during the merge
operation and/or at flush or commit time. In the absence of `Version`
columns there is no additional version checking done by the persistence
provider runtime during the merge operation.

===== Detached Entities and Lazy Loading

Serializing entities and merging those
entities back into a persistence context may not be interoperable across
vendors when lazy properties or fields and/or relationships are used.

A vendor is required to support the
serialization and subsequent deserialization and merging of detached
entity instances (which may contain lazy properties or fields and/or
relationships that have not been fetched) back into a separate JVM
instance of that vendor's runtime, where both runtime instances have
access to the entity classes and any required vendor persistence
implementation classes.

When interoperability across vendors is
required, the application must not use lazy loading.

==== Managed Instances

It is the responsibility of the application
to insure that an instance is managed in only a single persistence
context. The behavior is undefined if the same Java instance is made
managed in more than one persistence context.

The `contains()` method can be used to
determine whether an entity instance is managed in the current
persistence context.

The `contains` method returns true:

* If the entity has been retrieved from the
database or has been returned by `getReference`, and has not been
removed or detached.
* If the entity instance is new, and the
`persist` method has been called on the entity or the persist operation
has been cascaded to it.

The `contains` method returns false:

* If the instance is detached.
* If the `remove` method has been called on the
entity, or the remove operation has been cascaded to it.
* If the instance is new, and the `persist`
method has not been called on the entity or the persist operation has
not been cascaded to it.

Note that the effect of the cascading of
persist, merge, remove, or detach is immediately visible to the
`contains` method, whereas the actual insertion, modification, or
deletion of the database representation for the entity may be deferred
until the end of the transaction.

==== Load State [[a2019]]

An entity is considered to be loaded if all
attributes with `FetchType.EAGER` —whether explictly specified or by
default—(including relationship and other collection-valued attributes)
have been loaded from the database or assigned by the application.
Attributes with `FetchType.LAZY` may or may not have been loaded. The
available state of the entity instance and associated instances is as
described in <<a1982>>.

An attribute that is an embeddable is
considered to be loaded if the embeddable attribute was loaded from the
database or assigned by the application, and, if the attribute
references an embeddable instance (i.e., is not null), the embeddable
instance state is known to be loaded (i.e., all attributes of the
embeddable with `FetchType.EAGER` have been loaded from the database or
assigned by the application).

A collection-valued attribute is considered
to be loaded if the collection was loaded from the database or the value
of the attribute was assigned by the application, and, if the attribute
references a collection instance (i.e., is not null), each element of
the collection (e.g. entity or embeddable) is considered to be loaded.

A single-valued relationship attribute is
considered to be loaded if the relationship attribute was loaded from
the database or assigned by the application, and, if the attribute
references an entity instance (i.e., is not null), the entity instance
state is known to be loaded.

A basic attribute is considered to be loaded
if its state has been loaded from the database or assigned by the
application.

The `PersistenceUtil.isLoaded` methods can be
used to determine the load state of an entity and its attributes
regardless of the persistence unit with which the entity is associated.
The `PersistenceUtil.isLoaded` methods return true if the above
conditions hold, and false otherwise. If the persistence unit is known,
the `PersistenceUnitUtil.isLoaded` methods can be used instead. See <<a12177>>.

Persistence provider contracts for
determining the load state of an entity or entity attribute are
described in <<a13592>>.

=== Persistence Context Lifetime and Synchronization Type [[a2027]]

The lifetime of a container-managed
persistence context can either be scoped to a transaction
(transaction-scoped persistence context), or have a lifetime scope that
extends beyond that of a single transaction (extended persistence
context). The enum `PersistenceContextType` is used to define the
persistence context lifetime scope for container-managed entity
managers. The persistence context lifetime scope is defined when the
EntityManager instance is created (whether explicitly, or in conjunction
with injection or JNDI lookup). See <<a11791>>.

[source,java]
----
package jakarta.persistence;

public enum PersistenceContextType {
    TRANSACTION,
    EXTENDED
}
----

By default, the lifetime of the persistence
context of a container-managed entity manager corresponds to the scope
of a transaction (i.e., it is of type
`PersistenceContextType.TRANSACTION`).

When an extended persistence context is used,
the extended persistence context exists from the time the EntityManager
instance is created until it is closed. This persistence context might
span multiple transactions and non-transactional invocations of the
EntityManager.

An EntityManager with an extended persistence
context maintains its references to the entity objects after a
transaction has committed. Those objects remain managed by the
EntityManager, and they can be updated as managed objects between
transactions.footnote:[Note that when a new
transaction is begun, the managed objects in an extended persistence
context are `not` reloaded from the database.] Navigation from a managed object in
an extended persistence context results in one or more other managed
objects regardless of whether a transaction is active.

When an EntityManager with an extended
persistence context is used, the persist, remove, merge, and refresh
operations can be called regardless of whether a transaction is active.
The effects of these operations will be committed to the database when
the extended persistence context is enlisted in a transaction and the
transaction commits.

The scope of the persistence context of an
application-managed entity manager is extended. It is the responsibility
of the application to manage the lifecycle of the persistence context.

Container-managed persistence contexts are
described further in <<a11791>>. Persistence contexts managed by
the application are described further in <<a11894>>.

==== Synchronization with the Current Transaction

By default, a container-managed persistence
context is of `SynchronizationType.SYNCHRONIZED` and is automatically
joined to the current transaction. A persistence context of
`SynchronizationType.UNSYNCHRONIZED` will not be enlisted in the current
transaction, unless the `EntityManager` `joinTransaction` method is
invoked.

By default, an application-managed
persistence context that is associated with a JTA entity manager and
that is created within the scope of an active transaction is
automatically joined to that transaction. An application-managed JTA
persistence context that is created outside the scope of a transaction
or an application-managed persistence context of type
`SynchronizationType.UNSYNCHRONIZED` will not be joined to that
transaction unless the `EntityManager` `joinTransaction` method is
invoked.

An application-managed persistence context
associated with a resource-local entity manager is always automatically
joined to any resource-local transaction that is begun for that entity
manager.

Persistence context synchronization type is
described further in <<a11797>>.

==== Transaction Commit

The managed entities of a transaction-scoped
persistence context become detached when the transaction commits; the
managed entities of an extended persistence context remain managed.

==== Transaction Rollback [[a2049]]

For both transaction-scoped
persistence contexts and for extended persistence contexts that are
joined to the current transaction, transaction rollback causes all
_pre-existing_ managed instances and removed
instancesfootnote:[These are instances
that were persistent in the database at the start of the transaction.] to become detached. The instances'
state will be the state of the instances at the point at which the
transaction was rolled back. Transaction rollback typically causes the
persistence context to be in an inconsistent state at the point of
rollback. In particular, the state of version attributes and generated
state (e.g., generated primary keys) may be inconsistent. Instances that
were formerly managed by the persistence context (including new
instances that were made persistent in that transaction) may therefore
not be reusable in the same manner as other detached objects—for
example, they may fail when passed to the merge
operation.footnote:[It is unspecified as
to whether instances that were not persistent in the database behave as
new instances or detached instances after rollback. This may be
implementation-dependent.]

[NOTE]
====
Because a transaction-scoped
persistence context's lifetime is scoped to a transaction regardless of
whether it is joined to that transaction, the container closes the
persistence context upon transaction rollback. However, an extended
persistence context that is not joined to a transaction is unaffected by
transaction rollback.
====

=== Locking and Concurrency [[a2052]]

This specification assumes the use of
optimistic concurrency control. It assumes that the databases to which
persistence units are mapped will be accessed by the implementation
using read-committed isolation (or a vendor equivalent in which
long-term read locks are not held), and that writes to the database will
typically occur only when the `flush` method has been invoked—whether
explicitly by the application, or by the persistence provider runtime in
accordance with the flush mode setting.

[NOTE]
====
If a transaction is active and the
persistence context is joined to the transaction, a compliant
implementation of this specification is permitted to write to the
database immediately (i.e., whenever a managed entity is updated,
created, and/or removed), however, the configuration of an
implementation to require such non-deferred database writes is outside
the scope of this specification.footnote:[Applications may
require that database isolation levels higher than read-committed be in
effect. The configuration of the setting database isolation levels,
however, is outside the scope of this specification.]
====

In addition, both pessimistic and optimistic
locking are supported for selected entities by means of specified lock
modes. Optimistic locking is described in <<a2056>> and <<a2059>>; pessimistic locking
in <<a2066>>. <<a2084>> describes the setting of
optimistic and pessimistic lock modes. The configuration of the setting
of optimistic lock modes is described in <<a2100>>,
and the configuration of the setting of pessimistic lock modes is
described in <<a2113>>.

==== Optimistic Locking [[a2056]]

Optimistic locking is a technique that is
used to insure that updates to the database data corresponding to the
state of an entity are made only when no intervening transaction has
updated that data since the entity state was read. This insures that
updates or deletes to that data are consistent with the current state of
the database and that intervening updates are not lost. Transactions
that would cause this constraint to be violated result in an
`OptimisticLockException` being thrown and the transaction marked for
rollback.

Portable applications that wish to enable
optimistic locking for entities must specify `Version` attributes for
those entities—i.e., persistent properties or fields annotated with the
`Version` annotation or specified in the XML descriptor as version
attributes. Applications are strongly encouraged to enable optimistic
locking for all entities that may be concurrently accessed or that may
be merged from a disconnected state. Failure to use optimistic locking
may lead to inconsistent entity state, lost updates and other state
irregularities. If optimistic locking is not defined as part of the
entity state, the application must bear the burden of maintaining data
consistency.

==== Version Attributes [[a2059]]

The `Version` field or property is used by
the persistence provider to perform optimistic locking. It is accessed
and/or set by the persistence provider in the course of performing
lifecycle operations on the entity instance. An entity is automatically
enabled for optimistic locking if it has a property or field mapped with
a `Version` mapping.

An entity may access the state of its version
field or property or export a method for use by the application to
access the version, but must not modify the version
value.footnote:[Bulk update
statements, however, are permitted to set the value of version
attributes. See <<a5636>>.] With the exception noted in <<a5636>>, only
the persistence provider is permitted to set or update the value of the
version attribute in the object.

The version attribute is updated by the
persistence provider runtime when the object is written to the database.
All non-relationship fields and properties and all relationships owned
by the entity are included in version checks.footnote:[This includes owned
relationships maintained in join tables.]

The persistence provider's implementation of
the merge operation must examine the version attribute when an entity is
being merged and throw an `OptimisticLockException` if it is discovered
that the object being merged is a stale copy of the entity—i.e. that the
entity has been updated since the entity became detached. Depending on
the implementation strategy used, it is possible that this exception may
not be thrown until `flush` is called or commit time, whichever happens
first.

The persistence provider runtime is
required to use only the version attribute when performing optimistic
lock checking. Persistence provider implementations may provide
additional mechanisms beside version attributes to enable optimistic
lock checking. However, support for such mechanisms is not required of
an implementation of this specification.footnote:[Such additional
mechanisms may be standardized by a future release of this
specification.]

If only some entities contain version
attributes, the persistence provider runtime is required to check those
entities for which version attributes have been specified. The
consistency of the object graph is not guaranteed, but the absence of
version attributes on some of the entities will not stop operations from
completing.

==== Pessimistic Locking [[a2066]]

While optimistic locking is typically
appropriate in dealing with moderate contention among concurrent
transactions, in some applications it may be useful to immediately
obtain long-term database locks for selected entities because of the
often late failure of optimistic transactions. Such immediately obtained
long-term database locks are referred to here as “pessimistic”
locks.footnote:[Implementations are
permitted to use database mechanisms other than locking to achieve the
semantic effects described here, for example, multiversion concurrency
control mechanisms.]

Pessimistic locking guarantees that once a
transaction has obtained a pessimistic lock on an entity instance:

* no other transaction (whether a transaction
of an application using the Jakarta Persistence API or any other
transaction using the underlying resource) may successfully modify or
delete that instance until the transaction holding the lock has ended.
* if the pessimistic lock is an exclusive
lockfootnote:[This is achieved by
using a lock with `LockModeType.PESSIMISTIC_WRITE` or
`LockModeType.PESSIMISTIC_FORCE_INCREMENT` as described in <<a2084>>.],
that same transaction may modify or delete
that entity instance.

When an entity instance is locked using
pessimistic locking, the persistence provider must lock the database
row(s) that correspond to the non-collection-valued persistent state of
that instance. If a joined inheritance strategy is used, or if the
entity is otherwise mapped to a secondary table, this entails locking
the row(s) for the entity instance in the additional table(s). Entity
relationships for which the locked entity contains the foreign key will
also be locked, but not the state of the referenced entities (unless
those entities are explicitly locked). Element collections and
relationships for which the entity does not contain the foreign key
(such as relationships that are mapped to join tables or unidirectional
one-to-many relationships for which the target entity contains the
foreign key) will not be locked by default.

Element collections and relationships owned
by the entity that are contained in join tables will be locked if the
`jakarta.persistence.lock.scope` property is specified with a value of
`PessimisticLockScope.EXTENDED`. The state of entities referenced by
such relationships will not be locked (unless those entities are
explicitly locked). This property may be passed as an argument to the
methods of the `EntityManager`, `Query`, and `TypedQuery` interfaces
that allow lock modes to be specified or used with the `NamedQuery`
annotation.

Locking such a relationship or element
collection generally locks only the rows in the join table or collection
table for that relationship or collection. This means that phantoms will
be possible.

The values of the
`jakarta.persistence.lock.scope` property are defined by the
`PessimisticLockScope` enum.

[source,java]
----
package jakarta.persistence;

public enum PessimisticLockScope {
  NORMAL,
  EXTENDED
}
----

This specification does not define the
mechanisms a persistence provider uses to obtain database locks, and a
portable application should not rely on how pessimistic locking is
achieved on the database.footnote:[For example, a
persistence provider may use an underlying database platform's SELECT
FOR UPDATE statements to implement pessimistic locking if that construct
provides appropriate semantics, or the provider may use an isolation
level of repeatable read.] In particular, a
persistence provider or the underlying database management system may
lock more rows than the ones selected by the application.

Whenever a pessimistically locked entity
containing a version attribute is updated on the database, the
persistence provider must also update (increment) the entity's version
column to enable correct interaction with applications using optimistic
locking. See <<a2059>> and <<a2084>>.

Pessimistic locking may be applied to
entities that do not contain version attributes. However, in this case
correct interaction with applications using optimistic locking cannot be
ensured.

==== Lock Modes [[a2084]]

Lock modes are intended to provide a facility
that enables the effect of “repeatable read” semantics for the items
read, whether “optimistically” (as described in <<a2100>>)
or “pessimistically” (as described in <<a2113>>).

Lock modes can be specified by means of the
EntityManager `lock` method, the methods of the `EntityManager`,
`Query`, and `TypedQuery` interfaces that allow lock modes to be
specified, and the `NamedQuery` annotation.

Lock mode values are defined by the
`LockModeType` enum. Six distinct lock modes are defined. The lock mode
type values `READ` and `WRITE` are synonyms of `OPTIMISTIC` and
`OPTIMISTIC_FORCE_INCREMENT` respectively.footnote:[The lock mode type
NONE may be specified as a value of lock mode arguments and also
provides a default value for annotations.] The
latter are to be preferred for new applications.

[source,java]
----
package jakarta.persistence;

public enum LockModeType {
  READ,
  WRITE,
  OPTIMISTIC,
  OPTIMISTIC_FORCE_INCREMENT,
  PESSIMISTIC_READ,
  PESSIMISTIC_WRITE,
  PESSIMISTIC_FORCE_INCREMENT,
  NONE
}
----

===== OPTIMISTIC, OPTIMISTIC_FORCE_INCREMENT [[a2100]]

The lock modes `OPTIMISTIC` and
`OPTIMISTIC_FORCE_INCREMENT` are used for optimistic locking. The lock
mode type values `READ` and `WRITE` are synonymous with `OPTIMISTIC` and
`OPTIMISTIC_FORCE_INCREMENT` respectively.

The semantics of requesting locks of type
`LockModeType.OPTIMISTIC` and `LockModeType.OPTIMISTIC_FORCE_INCREMENT`
are the following.

If transaction T1 calls `lock(entity, LockModeType.OPTIMISTIC)` on a
versioned object, the entity manager
must ensure that neither of the following phenomena can occur:

* P1 (Dirty read): Transaction T1 modifies a
row. Another transaction T2 then reads that row and obtains the modified
value, before T1 has committed or rolled back. Transaction T2 eventually
commits successfully; it does not matter whether T1 commits or rolls
back and whether it does so before or after T2 commits.
* P2 (Non-repeatable read): Transaction T1
reads a row. Another transaction T2 then modifies or deletes that row,
before T1 has committed. Both transactions eventually commit
successfully.

This will generally be achieved by the entity
manager acquiring a lock on the underlying database row. While with
optimistic concurrency concurrency, long-term database read locks are
typically not obtained immediately, a compliant implementation is
permitted to obtain an immediate lock (so long as it is retained until
commit completes). If the lock is deferred until commit time, it must be
retained until the commit completes. Any implementation that supports
repeatable reads in a way that prevents the above phenomena is
permissible.

The persistence implementation is not
required to support calling `lock(entity, LockModeType.OPTIMISTIC)` on
a non-versioned object. When it cannot support such a lock call, it must
throw the `PersistenceException`. When supported, whether for versioned
or non-versioned objects, `LockModeType.OPTIMISTIC` must always prevent
the phenomena P1 and P2. Applications that call `lock(entity,
LockModeType.OPTIMISTIC)` on non-versioned objects will not be portable.

If transaction T1 calls `lock(entity, LockModeType.OPTIMISTIC_FORCE_INCREMENT)`
on a versioned object, the entity manager must avoid the phenomena P1 and P2
(as with `LockModeType.OPTIMISTIC`) and must also force an update (increment) to
the entity's version column. A forced version update may be performed
immediately, or may be deferred until a flush or commit. If an entity is
removed before a deferred version update was to have been applied, the
forced version update is omitted.

The persistence implementation is not required to support calling
`lock(entity, LockModeType.OPTIMISTIC_FORCE_INCREMENT)` on a non-versioned
object. When it cannot support such a lock call, it must throw the
`PersistenceException`. When supported, whether for versioned or
non-versioned objects, `LockModeType.OPTIMISTIC_FORCE_INCREMENT` must
always prevent the phenomena P1 and P2. For non-versioned objects,
whether or not `LockModeType.OPTIMISTIC_FORCE_INCREMENT` has any
additional behavior is vendor-specific. Applications that call
`lock(entity, LockModeType.OPTIMISTIC_FORCE_INCREMENT)_ on non-versioned
objects will not be portable.

For versioned objects, it is permissible for
an implementation to use `LockModeType.OPTIMISTIC_FORCE_INCREMENT` where
`LockModeType.OPTIMISTIC` was requested, but not vice versa.

If a versioned object is otherwise updated or
removed, then the implementation must ensure that the requirements of
`LockModeType.OPTIMISTIC_FORCE_INCREMENT` are met, even if no explicit
call to `EntityManager.lock` was made.

For portability, an application should not
depend on vendor-specific hints or configuration to ensure repeatable
read for objects that are not updated or removed via any mechanism other
than the use of version attributes and the EntityManager `lock` method.
However, it should be noted that if an implementation has acquired
up-front pessimistic locks on some database rows, then it is free to
ignore `lock(entity, LockModeType.OPTIMISTIC)` calls on the entity
objects representing those rows.

===== PESSIMISTIC_READ, PESSIMISTIC_WRITE, PESSIMISTIC_FORCE_INCREMENT [[a2113]]

The lock modes `PESSIMISTIC_READ`,
`PESSIMISTIC_WRITE`, and `PESSIMISTIC_FORCE_INCREMENT` are used to
immediately obtain long-term database locks.footnote:[Databases concurrency
control mechanisms that provide comparable semantics, e.g., multiversion
concurrency control, can be used by the provider.]

The semantics of requesting locks of type
`LockModeType.PESSIMISTIC_READ`, `LockModeType.PESSIMISTIC_WRITE`, and
`LockModeType.PESSIMISTIC_FORCE_INCREMENT` are the following.

If transaction T1 calls `lock(entity, LockModeType.PESSIMISTIC_READ)` or
`lock(entity, LockModeType.PESSIMISTIC_WRITE)` on an object, the entity
manager must ensure that neither of the following phenomena can occur:

* P1 (Dirty read): Transaction T1 modifies a
row. Another transaction T2 then reads that row and obtains the modified
value, before T1 has committed or rolled back.
* P2 (Non-repeatable read): Transaction T1
reads a row. Another transaction T2 then modifies or deletes that row,
before T1 has committed or rolled back.

Any such lock must be obtained immediately
and retained until transaction T1 completes (commits or rolls back).

Avoidance of phenomena P1 and P2 is generally
achieved by the entity manager acquiring a long-term lock on the
underlying database row(s). Any implementation that supports pessimistic
repeatable reads as described above is permissible.

[NOTE]
====
A lock with `LockModeType.PESSIMISTIC_WRITE`
can be obtained on an entity instance to force serialization among
transactions attempting to update the entity data. A lock with
`LockModeType.PESSIMISTIC_READ` can be used to query data using
repeatable-read semantics without the need to reread the data at the end
of the transaction to obtain a lock, and without blocking other
transactions reading the data. A lock with
`LockModeType.PESSIMISTIC_WRITE` can be used when querying data and
there is a high likelihood of deadlock or update failure among
concurrent updating transactions.
====

The persistence implementation must support
calling `lock(entity, LockModeType.PESSIMISTIC_READ)` and `lock(entity,
LockModeType.PESSIMISTIC_WRITE)` on a non-versioned entity as well as on
a versioned entity.

It is permissible for an implementation to
use `LockModeType.PESSIMISTIC_WRITE` where
`LockModeType.PESSIMISTIC_READ` was requested, but not vice versa.

When the lock cannot be obtained, and the
database locking failure results in transaction-level rollback, the
provider must throw the `PessimisticLockException` and ensure that the
JTA transaction or EntityTransaction has been marked for rollback.

When the lock cannot be obtained, and the
database locking failure results in only statement-level rollback, the
provider must throw the `LockTimeoutException` (and must not mark the
transaction for rollback).

When an application locks an entity with
`LockModeType.PESSIMISTIC_READ` and later updates that entity, the lock
must be converted to an exclusive lock when the entity is flushed to the
database.footnote:[The persistence
provider is not required to flush the entity to the database
immediately.] If the lock conversion fails, and the
database locking failure results in transaction-level rollback, the
provider must throw the `PessimisticLockException` and ensure that the
JTA transaction or EntityTransaction has been marked for rollback. When
the lock conversion fails, and the database locking failure results in
only statement-level rollback, the provider must throw the
`LockTimeoutException` (and must not mark the transaction for
rollback).

When `lock(entity, LockModeType.PESSIMISTIC_READ)`,
`lock(entity, LockModeType.PESSIMISTIC_WRITE)`, or
`lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT)`
is invoked on a versioned
entity that is already in the persistence context, the provider must
also perform optimistic version checks when obtaining the lock. An
`OptimisticLockException` must be thrown if the version checks fail.
Depending on the implementation strategy used by the provider, it is
possible that this exception may not be thrown until flush is called or
commit time, whichever occurs first.

If transaction T1 calls
`lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT)` on a versioned
object, the entity manager must avoid the phenomenon P1 and P2 (as with
`LockModeType.PESSIMISTIC_READ` and `LockModeType.PESSIMISTIC_WRITE`)
and must also force an update (increment) to the entity's version
column.

The persistence implementation is not required to support calling
`lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT)` on a non-versioned
object. When it cannot support such a lock call, it must throw the
`PersistenceException`. When supported, whether for versioned or
non-versioned objects, `LockModeType.PESSIMISTIC_FORCE_INCREMENT` must
always prevent the phenomena P1 and P2. For non-versioned objects,
whether or not `LockModeType.PESSIMISTIC_FORCE_INCREMENT` has any
additional behavior is vendor-specific. Applications that call
`lock(entity, LockModeType.PESSIMISTIC_FORCE_INCREMENT)` on
non-versioned objects will not be portable.

For versioned objects, it is permissible for
an implementation to use `LockModeType.PESSIMISTIC_FORCE_INCREMENT`
where `LockModeType.PESSIMISTIC_READ` or
`LockModeType.PESSIMISTIC_WRITE` was requested, but not vice versa.

If a versioned object locked with
`LockModeType.PESSIMISTIC_READ` or `LockModeType.PESSIMISTIC_WRITE` is
updated, then the implementation must ensure that the requirements of
`LockModeType.PESSIMISTIC_FORCE_INCREMENT` are met.

===== Lock Mode Properties and Uses [[a2132]]

The following property is defined by this
specification for use in pessimistic locking, as described in <<a2066>>:

[source,java]
----
jakarta.persistence.lock.scope
----

This property may be used with the methods of
the `EntityManager` interface that allow lock modes to be specified, the
`Query` and `TypedQuery` `setLockMode` methods, and the `NamedQuery`
annotation. When specified, this property must be observed. The provider
is permitted to lock more (but not fewer) rows than requested.

The following hint is defined by this
specification for use in pessimistic locking.

[source,java]
----
jakarta.persistence.lock.timeout // time in milliseconds
----

This hint may be used with the methods of the
`EntityManager` interface that allow lock modes to be specified, the
`Query.setLockMode` method and the `NamedQuery` annotation. It may also
be passed as a property to the `Persistence.createEntityManagerFactory`
method and used in the `properties` element of the `persistence.xml`
file. See <<a1066>>, <<a4385>>, <<a12384>>, <<a13443>>,
and <<a13711>>. When used in
the `createEntityManagerFactory` method, the `persistence.xml` file, and
the `NamedQuery` annotation, the timeout hint serves as a default value
which can be selectively overridden by use in the methods of the
`EntityManager`, `Query`, and `TypedQuery` interfaces as specified
above. When this hint is not specified, database timeout values are
assumed to apply.

A timeout value of `0` is used to specify “no wait” locking.

Portable applications should not rely on this
hint. Depending on the database in use and the locking mechanisms used
by the persistence provider, the hint may or may not be observed.

Vendors are permitted to support the use of
additional, vendor-specific locking hints. Vendor-specific hints must
not use the `jakarta.persistence` namespace. Vendor-specific hints must be
ignored if they are not understood.

If the same property or hint is specified
more than once, the following order of overriding applies, in order of
decreasing precedence:

* argument to method of `EntityManager`, `Query`, or `TypedQuery` interface
* specification to `NamedQuery` (annotation or XML)
* argument to `createEntityManagerFactory` method
* specification in `persistence.xml`

==== OptimisticLockException

Provider implementations may defer writing to
the database until the end of the transaction, when consistent with the
lock mode and flush mode settings in effect. In this case, an optimistic
lock check may not occur until commit time, and the
`OptimisticLockException` may be thrown in the “before completion” phase
of the commit. If the `OptimisticLockException` must be caught or
handled by the application, the `flush` method should be used by the
application to force the database writes to occur. This will allow the
application to catch and handle optimistic lock exceptions.

The `OptimisticLockException` provides an API
to return the object that caused the exception to be thrown. The object
reference is not guaranteed to be present every time the exception is
thrown but should be provided whenever the persistence provider can
supply it. Applications cannot rely upon this object being available.

In some cases an `OptimisticLockException`
will be thrown and wrapped by another exception, such as a
`RemoteException`, when VM boundaries are crossed. Entities that may be
referenced in wrapped exceptions should implement `Serializable` so that
marshalling will not fail.

An `OptimisticLockException` always causes
the transaction to be marked for rollback.

Refreshing objects or reloading objects in a
new transaction context and then retrying the transaction is a potential
response to an `OptimisticLockException`.

=== Entity Listeners and Callback Methods [[a2153]]

A method may be designated as a lifecycle
callback method to receive notification of entity lifecycle events. A
lifecycle callback method can be defined on an entity class, a mapped
superclass, or an entity listener class associated with an entity or
mapped superclass. An entity listener class is a class whose methods are
invoked in response to lifecycle events on an entity. Any number of
entity listener classes can be defined for an entity class or mapped
superclass.

Default entity listeners—entity listener
classes whose callback methods apply to all entities in the persistence
unit—can be specified by means of the XML descriptor.

Lifecycle callback methods and entity
listener classes are defined by means of metadata annotations or the XML
descriptor. When annotations are used, one or more entity listener
classes are denoted using the `EntityListeners` annotation on the entity
class or mapped superclass. If multiple entity listeners are defined,
the order in which they are invoked is determined by the order in which
they are specified in the `EntityListeners` annotation. The XML
descriptor may be used as an alternative to specify the invocation order
of entity listeners or to override the order specified in metadata
annotations.

Any subset or combination of annotations may
be specified on an entity class, mapped superclass, or listener class. A
single class must not have more than one lifecycle callback method for
the same lifecycle event. The same method may be used for multiple
callback events.

Multiple entity classes and mapped
superclasses in an inheritance hierarchy may define listener classes
and/or lifecycle callback methods directly on the class. <<a2251>>
describes the rules that apply to method invocation order in this case.

==== Entity Listeners

The entity listener class must have a public no-arg constructor.

Entity listener classes in Jakarta EE
environments support dependency injection through the Contexts and
Dependency Injection API (CDI) <<a19500>> when CDI is
enabledfootnote:[CDI is enabled by
default in Jakarta EE. See the Jakarta EE specification
<<a19499>>.]. An entity listener class that makes use
of CDI injection may also define lifecycle callback methods annotated
with the `PostConstruct` and `PreDestroy` annotations. These methods
will be invoked after injection has taken place and before the entity
listener instance is destroyed respectively.

The persistence provider is responsible for
using the CDI SPI to create instances of the entity listener class; to
perform injection upon such instances; to invoke their `PostConstruct`
and `PreDestroy` methods, if any; and to dispose of the entity listener
instances.

The persistence provider is only required to
support CDI injection into entity listeners in Jakarta EE container
environmentsfootnote:[The persistence
provider may support CDI injection into entity listeners in other
environments in which the BeanManager is available.]. If the CDI is not enabled, the
persistence provider must not invoke entity listeners that depend upon
CDI injection.

An entity listener is a noncontextual object.
In supporting injection into entity listeners, the persistence provider
must behave as if it carries out the following steps involving the use
of the CDI SPI. (See <<a19500>>).

* Obtain a `BeanManager` instance. (See <<a12802>>)
* Create an `AnnotatedType` instance for the entity listener class.
* Create an `InjectionTarget` instance for the annotated type.
* Create a `CreationalContext`.
* Instantiate the listener by calling the `InjectionTarget` `produce` method.
* Inject the listener instance by calling the
`InjectionTarget` `inject` method on the instance.
* Invoke the `PostConstruct` callback, if any,
by calling the `InjectionTarget` `postConstruct` method on the instance.

When the listener instance is to be
destroyed, the persistence provider must behave as if it carries out the
following steps.

* Call the `InjectionTarget` `preDestroy` method on the instance.
* Call the `InjectionTarget` `dispose` method on the instance
* Call the `CreationalContext` `release` method.

Persistence providers may optimize the steps
above, e.g. by avoiding calls to the actual CDI SPI and relying on
container-specific interfaces instead, as long as the outcome is the
same.

Entity listeners that do not make use of CDI
injection are stateless. The lifecycle of such entity listeners is
unspecified.

When invoked from within a Jakarta EE
environment, the callback listeners for an entity share the enterprise
naming context of the invoking component, and the entity callback
methods are invoked in the transaction and security contexts of the
calling component at the time at which the callback method is invoked.
footnote:[For example, if a
transaction commit occurs as a result of the normal termination of a
session bean business method with transaction attribute `RequiresNew`,
the `PostPersist` and `PostRemove` callbacks are executed in the naming
context, the transaction context, and the security context of that
component.]

==== Lifecycle Callback Methods

Entity lifecycle callback methods can be defined on an entity listener
class and/or directly on an entity class or mapped superclass.

A lifecycle callback method must be either:

- annotated with annotations designating the callback events for which
  it is invoked, or
- mapped to a callback event type using the XML descriptor.

The same annotations (and XML elements) are used to declare:

- callback methods of an entity class or mapped superclass, and
- callback methods of an entity listener class.

The signatures of the callback methods differ between these two cases:

- a callback method defined by an entity class or mapped superclass has
  the signature:
+
 void <METHOD>()
+
- a callback method defined by an entity listener class has the signature:
+
 void <METHOD>(S)
+
where `S` is any supertype of the entity class or mapped superclass to
which the entity listener is applied. At runtime, the argument to the
entity listener callback method is the entity instance for which the
callback method is being invoked.

Callback methods can have public, private, protected, or package level
access, but must not be `static` or `final`.

The following annotations designate lifecycle event callback methods of
the corresponding types.

* `PrePersist`
* `PostPersist`
* `PreRemove`
* `PostRemove`
* `PreUpdate`
* `PostUpdate`
* `PostLoad`

The following rules apply to lifecycle callback methods:

* Lifecycle callback methods may throw unchecked/runtime exceptions.
  A runtime exception thrown by a callback method that executes within
  a transaction causes that transaction to be marked for rollback if
  the persistence context is joined to the transaction.
* Lifecycle callbacks can invoke JNDI, JDBC, JMS, and enterprise beans.
* A lifecycle callback method may modify the non-relationship state of
  the entity on which it is invoked.
* In general, the lifecycle method of a portable application should not
  invoke `EntityManager` or query operations, access other entity
  instances, or modify relationships within the same persistence
  contextfootnote:[Note that this caution applies also to the actions of
  objects that might be injected into an entity listener].

==== Semantics of the Life Cycle Callback Methods for Entities [[a2202]]

The `PrePersist` and `PreRemove` callback
methods are invoked for a given entity before the respective
EntityManager persist and remove operations for that entity are
executed. For entities to which the merge operation has been applied and
causes the creation of newly managed instances, the `PrePersist`
callback methods will be invoked for the managed instance after the
entity state has been copied to it. These `PrePersist` and `PreRemove`
callbacks will also be invoked on all entities to which these operations
are cascaded. The `PrePersist` and `PreRemove` methods will always be
invoked as part of the synchronous persist, merge, and remove operations.
Primary key values generated using the `SEQUENCE`, `TABLE`, or `UUID`
strategy are available in the `PrePersist` method. Primary key values
generated using the `IDENTITY` strategy are not available in the
`PrePersist` method.

The `PostPersist` and `PostRemove` callback
methods are invoked for an entity after the entity has been made
persistent or removed. These callbacks will also be invoked on all
entities to which these operations are cascaded. The `PostPersist` and
`PostRemove` methods will be invoked after the database insert and
delete operations respectively. These database operations may occur
directly after the persist, merge, or remove operations have been
invoked or they may occur directly after a flush operation has occurred
(which may be at the end of the transaction). Generated primary key
values are always available in the `PostPersist` method.

The `PreUpdate` and `PostUpdate` callbacks
occur before and after the database update operations to entity data
respectively. These database operations may occur at the time the entity
state is updated or they may occur at the time state is flushed to the
database (which may be at the end of the transaction).

[NOTE]
====
Note that it is implementation-dependent as
to whether `PreUpdate` and `PostUpdate` callbacks occur when an entity
is persisted and subsequently modified in a single transaction or when
an entity is modified and subsequently removed within a single
transaction. Portable applications should not rely on such behavior.
====

The `PostLoad` method for an entity is
invoked after the entity has been loaded into the current persistence
context from the database or after the refresh operation has been
applied to it. The `PostLoad` method is invoked before a query result is
returned or accessed or before an association is traversed.

It is implementation-dependent as to whether
callback methods are invoked before or after the cascading of the
lifecycle events to related entities. Applications should not depend on
this ordering.

For example:

[source,java]
----
@Entity
@EntityListeners(com.acme.AlertMonitor.class)
public class Account {
    Long accountId;
    Integer balance;
    boolean preferred;

    @Id
    public Long getAccountId() { ... }

    // ...

    public Integer getBalance() { ... }

    // ...

    @Transient // because status depends upon non-persistent context
    public boolean isPreferred() { ... }

    // ...

    public void deposit(Integer amount) { ... }

    public Integer withdraw(Integer amount) throws NSFException { ... }

    @PrePersist
    protected void validateCreate() {
        if (getBalance() < MIN_REQUIRED_BALANCE)
            throw new AccountException("Insufficient balance to open an account");
    }

    @PostLoad
    protected void adjustPreferredStatus() {
        preferred = (getBalance() >= AccountManager.getPreferredStatusLevel());
    }
}

public class AlertMonitor {
    @PostPersist
    public void newAccountAlert(Account acct) {
        Alerts.sendMarketingInfo(acct.getAccountId(), acct.getBalance());
    }
}
----

==== Multiple Lifecycle Callback Methods for an Entity Lifecycle Event [[a2251]]

If multiple callback methods are defined for
an entity lifecycle event, the ordering of the invocation of these
methods is as follows.

Default listeners, if any, are invoked first,
in the order specified in the XML descriptor. Default listeners apply to
all entities in the persistence unit, unless explicitly excluded by
means of the `ExcludeDefaultListeners` annotation or
`exclude-default-listeners` XML element.

The lifecycle callback methods defined on the
entity listener classes for an entity class or mapped superclass are
invoked in the same order as the specification of the entity listener
classes in the `EntityListeners` annotation.

If multiple classes in an inheritance
hierarchy—entity classes and/or mapped superclasses—define entity
listeners, the listeners defined for a superclass are invoked before the
listeners defined for its subclasses in this order. The
`ExcludeSuperclassListeners` annotation or
`exclude-superclass-listeners` XML element may be applied to an entity
class or mapped superclass to exclude the invocation of the listeners
defined by the entity listener classes for the superclasses of the
entity or mapped superclass. The excluded listeners are excluded from
the class to which the `ExcludeSuperclassListeners` annotation or
element has been specified and its subclassesfootnote:[Excluded listeners
may be reintroduced on an entity class by listing them explicitly in the
`EntityListeners` annotation or XML `entity-listeners` element.].
The `ExcludeSuperclassListeners` annotation (or
`exclude-superclass-listeners` XML element) does not cause default
entity listeners to be excluded from invocation.

If a lifecycle callback method for the
same lifecycle event is also specified on the entity class and/or one or
more of its entity or mapped superclasses, the callback methods on the
entity class and/or superclasses are invoked after the other lifecycle
callback methods, most general superclass first. A class is permitted to
override an inherited callback method of the same callback type, and in
this case, the overridden method is not invokedfootnote:[If a method overrides
an inherited callback method but specifies a different lifecycle event
or is not a lifecycle callback method, the overridden method will not be
invoked.].

Callback methods are invoked by the
persistence provider runtime in the order specified. If the callback
method execution terminates normally, the persistence provider runtime
then invokes the next callback method, if any.

The XML descriptor may be used to override
the lifecycle callback method invocation order specified in annotations.

For example:

There are several entity classes and listeners for animals:

[source,java]
----
@Entity
public class Animal {

    // ...

    @PostPersist
    protected void postPersistAnimal() {
        // ...
    }
}

@Entity
@EntityListeners(PetListener.class)
public class Pet extends Animal {
    // ...
}

@Entity
@EntityListeners({CatListener.class, CatListener2.class})
public class Cat extends Pet {
    // ...
}

public class PetListener {
    @PostPersist
    protected void postPersistPetListenerMethod(Object pet) {
        // ...
    }
}

public class CatListener {
    @PostPersist
    protected void postPersistCatListenerMethod(Object cat) {
        // ...
    }
}

public class CatListener2 {
    @PostPersist
    protected void postPersistCatListener2Method(Object cat) {
        // ...
    }
}
----

If a `PostPersist` event occurs on an
instance of `Cat`, the following methods are called in order:

. postPersistPetListenerMethod
. postPersistCatListenerMethod
. postPersistCatListener2Method
. postPersistAnimal

Assume that `SiameseCat` is defined as a
subclass of `Cat`:

[source,java]
----
@EntityListeners(SiameseCatListener.class)
@Entity
public class SiameseCat extends Cat {
    // ...

    @PostPersist
    protected void postPersistSiameseCat() {
        // ...
    }
}

public class SiameseCatListener {
    @PostPersist
    protected void postPersistSiameseCatListenerMethod(Object cat) {
        // ...
    }
}
----

If a `PostPersist` event occurs on an
instance of `SiameseCat`, the following methods are called in order:

. postPersistPetListenerMethod
. postPersistCatListenerMethod
. postPersistCatListener2Method
. postPersistSiameseCatListenerMethod
. postPersistAnimal
. postPersistSiameseCat

Assume the definition of `SiameseCat` were instead:

[source,java]
----
@EntityListeners(SiameseCatListener.class)
@Entity
public class SiameseCat extends Cat {
    // ...

    @PostPersist
    protected void postPersistAnimal() {
        // ...
    }
}
----

In this case, the following methods would be
called in order, where `postPersistAnimal` is the `PostPersist` method
defined in the `SiameseCat` class:

. postPersistPetListenerMethod
. postPersistCatListenerMethod
. postPersistCatListener2Method
. postPersistSiameseCatListenerMethod
. postPersistAnimal

==== Exceptions

Lifecycle callback methods may throw runtime
exceptions. A runtime exception thrown by a callback method that
executes within a transaction causes that transaction to be marked for
rollback if the persistence context is joined to the transaction. No
further lifecycle callback methods will be invoked after a runtime
exception is thrown.

==== Specification of Callback Listener Classes and Lifecycle Methods in the XML Descriptor

The XML descriptor can be used as an
alternative to metadata annotations to specify entity listener classes
and their binding to entities or to override the invocation order of
lifecycle callback methods as specified in annotations.

===== Specification of Callback Listeners

The `entity-listener` XML descriptor element
is used to specify the lifecycle listener methods of an entity listener
class. The lifecycle listener methods are specified by using the
`pre-persist`, `post-persist`, `pre-remove`, `post-remove`,
`pre-update`, `post-update`, and/or `post-load` elements.

An entity listener class can define multiple
callback methods. However, at most one method of an entity listener
class can be designated as a pre-persist method, post-persist method,
pre-remove method, post-remove method, pre-update method, post-update
method, and/or post-load method, regardless of whether the XML
descriptor is used to define entity listeners or whether some
combination of annotations and XML descriptor elements is used.

===== Specification of the Binding of Entity Listener Classes to Entities

The `entity-listeners` subelement of the
`persistence-unit-defaults` element is used to specify the default
entity listeners for the persistence unit.

The `entity-listeners` subelement of the
`entity` or `mapped-superclass` element is used to specify the entity
listener classes for the respective entity or mapped superclass and its
subclasses.

The binding of entity listeners to entity
classes is additive. The entity listener classes bound to the
superclasses of an entity or mapped superclass are applied to it as
well.

The `exclude-superclass-listeners` element
specifies that the listener methods for superclasses are not to be
invoked for an entity class (or mapped superclass) and its subclasses.

The `exclude-default-listeners` element
specifies that default entity listeners are not to be invoked for an
entity class (or mapped superclass) and its subclasses.

Explicitly listing an excluded default or
superclass listener for a given entity class or mapped superclass causes
it to be applied to that entity or mapped superclass and its subclasses.

In the case of multiple callback methods for
a single lifecycle event, the invocation order rules described in <<a2251>> apply.

=== Bean Validation [[a2366]]

This specification defines support for use of
Bean Validation <<a19498>> within Jakarta Persistence
applications.

Managed classes (entities, mapped
superclasses, and embeddable classes) may be configured to include Bean
Validation constraints.

Automatic validation using these constraints
is achieved by specifying that Jakarta Persistence delegate validation to
the Bean Validation implementation upon the pre-persist, pre-update, and
pre-remove entity lifecycle events described in <<a2202>>.

Validation can also be achieved by the
application calling the `validate` method of a `Validator` instance upon
an instance of a managed class, as described in the Bean Validation
specification <<a19498>>.

==== Automatic Validation Upon Lifecycle Events

This specification supports the use of bean
validation for the automatic validation of entities upon the
pre-persist, pre-update, and pre-remove lifecycle validation events.
These lifecycle validation events occur immediately after the point at
which all the `PrePersist`, `PreUpdate`, and `PreRemove` lifecycle
callback method invocations respectively have been completed, or
immediately after the point at which such lifecycle callback methods
would have been completed (in the event that such callback methods are
not present).

[NOTE]
====
In the case where an entity is persisted and
subsequently modified in a single transaction or when an entity is
modified and subsequently removed in a single transaction, it is
implementation dependent as to whether the pre-update validation event
occurs. Portable applications should not rely on this behavior.
====

===== Enabling Automatic Validation [[a2374]]

The `validation-mode` element of the
`persistence.xml` file determines whether the automatic lifecycle event
validation is in effect. The values of the `validation-mode` element are
`AUTO`, `CALLBACK`, `NONE`. The default validation mode is `AUTO`.

If the application creates the entity manager
factory using the `Persistence.createEntityManagerFactory` method, the
validation mode can be specified using the
`jakarta.persistence.validation.mode` map key, which will override the
value specified (or defaulted) in the `persistence.xml` file. The map
values for this key are _"auto"_, _"callback"_, _"none"_.

If the auto validation mode is specified by
the `validation-mode` element or the `jakarta.persistence.validation.mode`
property, or if neither the `validation-mode` element nor the
`jakarta.persistence.validation.mode` property is specified, and a Bean
Validation provider is present in the environment, the persistence
provider must perform the automatic validation of entities as described
in <<a2380>>. If no Bean Validation provider is
present in the environment, no lifecycle event validation takes place.

If the callback validation mode is specified
by the `validation-mode` element or the
`jakarta.persistence.validation.mode` property, the persistence provider
must perform the lifecycle event validation as described in <<a2380>>.
It is an error if there is no Bean Validation
provider present in the environment, and the provider must throw the
`PersistenceException` if the `jakarta.persistence.validation.mode`
property value _"callback"_ has been passed to the
`Persistence.createEntityManagerFactory` method.

If the none validation mode is specified by
the `validation-mode` element or the `jakarta.persistence.validation.mode`
property, the persistence provider must not perform lifecycle event
validation.

===== Requirements for Automatic Validation upon Lifecycle Events [[a2380]]

For each event type, a list of groups is
targeted for validation. By default, the default Bean Validation group
(the group `Default`) will be validated upon the pre-persist and
pre-update lifecycle validation events, and no group will be validated
upon the pre-remove event.

This default validation behavior can be
overridden by specifying the target groups using the following
validation properties in the `persistence.xml` file or by passing these
properties in the configuration of the entity manager factory through
the `createEntityManagerFactory` method:


* `jakarta.persistence.validation.group.pre-persist`
* `jakarta.persistence.validation.group.pre-update`
* `jakarta.persistence.validation.group.pre-remove`

The value of a validation property must be a
list of the targeted groups. A targeted group must be specified by its
fully qualified class name. Names must be separated by a comma.

When one of the above events occurs for an
entity, the persistence provider must validate that entity by obtaining
a `Validator` instance from the validator factory in use (see <<a2394>>) and
invoking its `validate` method with the targeted groups. If the list of
targeted groups is empty, no validation is performed. If the set of
`ConstraintViolation` objects returned by the `validate` method is not
empty, the persistence provider must throw the
`jakarta.validation.ConstraintViolationException` containing a reference
to the returned set of `ConstraintViolation` objects, and must mark the
transaction for rollback if the persistence context is joined to the
transaction.

The validator instance that is used for
automatic validation upon lifecycle events must use a
`TraversableResolver` that has the following behavior:

* Attributes that have not been loaded must not
be loaded.
* Validation cascade (`@Valid`) must not
occur for entity associations (single- or multi-valued).

These requirements guarantee that no unloaded
attribute or association will be loaded by side effect and that no
entity will be validated more than once during a given flush cycle.

Embeddable attributes must be validated only
if the `Valid` annotation has been specified on them.

It is the responsibility of the persistence
provider to pass an instance implementing the
`jakarta.validation.TraversableResolver` interface to the Bean Validation
provider by calling
`ValidatorFactory.usingContext().traversableResolver(tr).getValidator()` where `tr` is the resolver having the behavior described above.

==== Providing the ValidatorFactory [[a2394]]

In Jakarta EE environments, a `ValidatorFactory`
instance is made available by the Jakarta EE container. The container is
responsible for passing this validator factory to the persistence
provider via the map that is passed as an argument to the
`createContainerEntityManagerFactory` call. The map key used by the
container must be the standard property name
`jakarta.persistence.validation.factory`.

In Java SE environments, the application can
pass the `ValidatorFactory` instance via the map that is passed as an
argument to the `Persistence.createEntityManagerFactory` call. The map
key used must be the standard property name
`jakarta.persistence.validation.factory`. If no `ValidatorFactory`
instance is provided by the application, and if a Bean Validation
provider is present in the classpath, the persistence provider must
instantiate the `ValidatorFactory` using the default bootstrapping
approach defined by the Bean Validation specification
<<a19498>>, namely `Validation.buildDefaultValidatorFactory()`.

=== Entity Graphs [[a2397]]

An entity graph is a template that captures
the path and boundaries for an operation or query. It is defined in the
form of metadata or an object created by the dynamic `EntityGraph` API.

Entity graphs are used in the specification
of “fetch plans” for query or `find` operations.

The `EntityGraph`, `AttributeNode`, and
`Subgraph` interfaces are used to dynamically construct entity graphs.
The annotations to statically define entity graphs, namely
`NamedEntityGraph`, `NamedAttributeNode`, and `NamedSubgraph`, are
described in <<a13662>>.
The `named-entity-graph` XML element and its subelements may be used to
override these annotations or to define additional named entity graphs.

The semantics of entity graphs with regard to
find and query operations are described in <<a2814>>.

==== Graph Interface

[source,java]
----
package jakarta.persistence;

import jakarta.persistence.metamodel.Attribute;
import jakarta.persistence.metamodel.MapAttribute;
import jakarta.persistence.metamodel.PluralAttribute;

import java.util.List;

/**
* Declares operations common to {@link EntityGraph} and {@link Subgraph}.
*
* @see EntityGraph
* @see Subgraph
*
* @since 3.2
*/
public interface Graph<T> {

    /**
     * Add an attribute nodes to the entity graph.
     *
     * @param attributeName  name of the attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this entity.
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     *
     * @since 3.2
     */
    public void addAttributeNode(String attributeName);

    /**
     * Add an attribute node to the entity graph.
     *
     * @param attribute  attribute
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     *
     * @since 3.2
     */
    public void addAttributeNode(Attribute<? super T, ?> attribute);

    /**
     * Remove an attribute node from the entity graph.
     * When this graph is interpreted as a load graph, this operation
     * suppresses inclusion of an attribute mapped for eager fetching.
     * The effect of this call may be overridden by subsequent
     * invocations of {@link #addAttributeNode} or {@link #addSubgraph}.
     * @param attributeName  name of the attribute
     * @since 3.2
     */
    public void removeAttributeNode(String attributeName);

    /**
     * Remove an attribute node from the entity graph.
     * When this graph is interpreted as a load graph, this operation
     * suppresses inclusion of an attribute mapped for eager fetching.
     * The effect of this call may be overridden by subsequent
     * invocations of {@link #addAttributeNode} or {@link #addSubgraph}.
     * @param attribute  attribute
     * @since 3.2
     */
    public void removeAttributeNode(Attribute<? super T, ?> attribute);

    /**
     * Remove all attribute nodes of the given attribute types.
     * When this graph is interpreted as a load graph, this operation
     * suppresses inclusion of attributes mapped for eager fetching.
     * The effect of this call may be overridden by subsequent
     * invocations of {@link #addAttributeNode} or {@link #addSubgraph}.
     * @since 3.2
     */
    public void removeAttributeNodes(Attribute.PersistentAttributeType nodeTypes);

    /**
     * Add one or more attribute nodes to the entity graph.
     *
     * @param attributeName  name of the attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this managed type.
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     */
    public void addAttributeNodes(String ... attributeName);

    /**
     * Add one or more attribute nodes to the entity graph.
     * @param attribute  attribute
     *
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public void addAttributeNodes(Attribute<? super T, ?>... attribute);

    /**
     * Add a node to the graph that corresponds to a managed
     * type. This allows for construction of multi-node entity graphs
     * that include related managed types.
     *
     * @param attribute  attribute
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addSubgraph(Attribute<? super T, X> attribute);

    /**
     * Add a node to the graph that corresponds to a managed
     * type with inheritance.  This allows for multiple subclass
     * subgraphs to be defined for this node of the entity
     * graph. Subclass subgraphs will automatically include the
     * specified attributes of superclass subgraphs.
     *
     * @param attribute  attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     *
     * @since 3.2
     */
    public <Y> Subgraph<Y> addTreatedSubgraph(Attribute<? super T, ? super Y> attribute, Class<Y> type);

    /**
     * Add a node to the graph that corresponds to a managed
     * type with inheritance.  This allows for multiple subclass
     * subgraphs to be defined for this node of the entity
     * graph. Subclass subgraphs will automatically include the specified
     * attributes of superclass subgraphs
     *
     * @param attribute  attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     * @deprecated use {@link #addTreatedSubgraph(Attribute, Class)}
     */
    @Deprecated(since = "3.2", forRemoval = true)
    public <X> Subgraph<? extends X> addSubgraph(Attribute<? super T, X> attribute, Class<? extends X> type);

    /**
     * Add a node to the graph that corresponds to a managed
     * type. This allows for construction of multi-node entity graphs
     * that include related managed types.
     *
     * @param attributeName  name of the attribute
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this managed type.
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addSubgraph(String attributeName);

    /**
     * Add a node to the graph that corresponds to a managed
     * type with inheritance.  This allows for multiple subclass
     * subgraphs to be defined for this node of the entity
     * graph. Subclass subgraphs will automatically include the
     * specified attributes of superclass subgraphs
     *
     * @param attributeName  name of the attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute is not
     *         an attribute of this managed type.
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addSubgraph(String attributeName, Class<X> type);

    /**
     * Add a node to the graph that corresponds to a collection element
     * that is a managed type. This allows for construction of
     * multi-node entity graphs that include related managed types.
     *
     * @param attribute  attribute
     * @return subgraph for the element attribute
     * @throws IllegalArgumentException if the attribute's target type
     *         is not an entity
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     *
     * @since 3.2
     */
    public <E> Subgraph<E> addElementSubgraph(PluralAttribute<? super T, ?, E> attribute);

    /**
     * Add a node to the graph that corresponds to a collection element
     * that is a managed type. This allows for construction of
     * multi-node entity graphs that include related managed types.
     *
     * @param attribute  attribute
     * @return subgraph for the element attribute
     * @throws IllegalArgumentException if the attribute's target type
     *         is not an entity
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     *
     * @since 3.2
     */
    public <E> Subgraph<E> addTreatedElementSubgraph(PluralAttribute<? super T, ?, ? super E> attribute, Class<E> type);

    /**
     * Add a node to the graph that corresponds to a collection element
     * that is a managed type. This allows for construction of
     * multi-node entity graphs that include related managed types.
     *
     * @param attributeName  name of the attribute
     * @return subgraph for the element attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this entity.
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *          statically defined
     */
    public <X> Subgraph<X> addElementSubgraph(String attributeName);

    /**
     * Add a node to the graph that corresponds to a collection element
     * that is a managed type. This allows for construction of
     * multi-node entity graphs that include related managed types.
     *
     * @param attributeName  name of the attribute
     * @param type  entity subclass
     * @return subgraph for the element attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this entity.
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *          statically defined
     */
    public <X> Subgraph<X> addElementSubgraph(String attributeName, Class<X> type);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type. This allows for construction of
     * multi-node entity graphs that include related managed types.
     *
     * @param attribute  attribute
     * @return subgraph for the key attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type entity
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <K> Subgraph<K> addMapKeySubgraph(MapAttribute<? super T, K, ?> attribute);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type with inheritance. This allows for
     * construction of multi-node entity graphs that include related
     * managed types.  Subclass subgraphs will automatically include
     * the specified attributes of superclass subgraphs
     *
     * @param attribute  attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type entity
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <K> Subgraph<K> addTreatedMapKeySubgraph(MapAttribute<? super T, ? super K, ?> attribute, Class<K> type);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type. This allows for construction of
     * multi-node entity graphs that include related managed types.
     *
     * @param attribute  attribute
     * @return subgraph for the key attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type entity
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     * @deprecated use {@link #addMapKeySubgraph(MapAttribute)}
     */
    @Deprecated(since = "3.2", forRemoval = true)
    public <X> Subgraph<X> addKeySubgraph(Attribute<? super T, X> attribute);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type with inheritance. This allows for
     * construction of multi-node entity graphs that include related
     * managed types.  Subclass subgraphs will automatically include
     * the specified attributes of superclass subgraphs
     *
     * @param attribute  attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type entity
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     * @deprecated use {@link #addTreatedMapKeySubgraph(MapAttribute, Class)}
     */
    @Deprecated(since = "3.2", forRemoval = true)
    public <X> Subgraph<? extends X> addKeySubgraph(Attribute<? super T, X> attribute, Class<? extends X> type);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type. This allows for construction of
     * multi-node entity graphs that include related managed types.
     *
     * @param attributeName  name of the attribute
     * @return subgraph for the key attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this entity.
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *          statically defined
     */
    public <X> Subgraph<X> addKeySubgraph(String attributeName);

    /**
     * Add a node to the graph that corresponds to a map key
     * that is a managed type with inheritance. This allows for
     * construction of multi-node entity graphs that include related
     * managed types.  Subclass subgraphs will include the specified
     * attributes of superclass subgraphs
     *
     * @param attributeName  name of the attribute
     * @param type  entity subclass
     * @return subgraph for the attribute
     * @throws IllegalArgumentException if the attribute is not an
     *         attribute of this entity.
     * @throws IllegalArgumentException if the attribute's target
     *         type is not a managed type
     * @throws IllegalStateException if this EntityGraph has been
     *         statically defined
     */
    public <X> Subgraph<X> addKeySubgraph(String attributeName, Class<X> type);

    /**
     * Return the attribute nodes corresponding to the attributes of
     * this managed type that are included in the graph.
     * @return list of attribute nodes included in the graph or an
     * empty list if none have been defined
     */
    public List<AttributeNode<?>> getAttributeNodes();

}
----

The deprecated methods of this interface will be removed
in a future major release of this specification.

==== EntityGraph Interface

[source,java]
----
package jakarta.persistence;

/**
 * This type represents the root of an entity graph that will be used
 * as a template to define the attribute nodes and boundaries of a
 * graph of entities and entity relationships. The root must be an
 * entity type.
 * <p>
 * The methods to add subgraphs implicitly create the
 * corresponding attribute nodes as well; such attribute nodes
 * should not be redundantly specified.
 *
 * @param <T> The type of the root entity.
 *
 * @see AttributeNode
 * @see Subgraph
 * @see NamedEntityGraph
 *
 * @since 2.1
 */
public interface EntityGraph<T> extends Graph<T> {

    /**
     * Return the name of a named EntityGraph (an entity graph
     * defined by means of the <code>NamedEntityGraph</code>
     * annotation, XML descriptor element, or added by means of the
     * <code>addNamedEntityGraph</code> method.  Returns null if the
     * EntityGraph is not a named EntityGraph.
     */
    public String getName();

    /**
     * Add additional attributes to this entity graph that
     * correspond to attributes of subclasses of this EntityGraph's
     * entity type.  Subclass subgraphs will automatically include the
     * specified attributes of superclass subgraphs.
     *
     * @param type  entity subclass
     * @return subgraph for the subclass
     * @throws IllegalArgumentException if the type is not an entity type
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     */
    public <S extends T> Subgraph<S> addTreatedSubgraph(Class<S> type);

    /**
     * Add additional attributes to this entity graph that
     * correspond to attributes of subclasses of this EntityGraph's
     * entity type.  Subclass subgraphs will automatically include the
     * specified attributes of superclass subgraphs.
     *
     * @param type  entity subclass
     * @return subgraph for the subclass
     * @throws IllegalArgumentException if the type is not an entity type
     * @throws IllegalStateException if the EntityGraph has been
     *         statically defined
     * @deprecated use {@link #addTreatedSubgraph(Class)}
     */
    @Deprecated(since = "3.2", forRemoval = true)
    public <T> Subgraph<? extends T> addSubclassSubgraph(Class<? extends T> type);

}
----

The deprecated method of this interface will be removed
in a future major release of this specification.

==== AttributeNode Interface

[source,java]
----
package jakarta.persistence;

import java.util.Map;

/**
 * Represents an attribute node of an entity graph.
 *
 * @param <T> The type of the attribute.
 *
 * @see EntityGraph
 * @see Subgraph
 * @see NamedAttributeNode
 *
 * @since 2.1
 */
public interface AttributeNode<T> {

    /**
     * Return the name of the attribute corresponding to the
     * attribute node.
     * @return name of the attribute
     */
    public String getAttributeName();

    /**
     * Return the Map&#060;Class, Subgraph&#062; of subgraphs associated
     * with this attribute node.
     * @return Map of subgraphs associated with this attribute node
     * or empty Map if none have been defined
     */
    public Map<Class, Subgraph> getSubgraphs();

    /**
     * Return the Map&#060;Class, Subgraph&#062; of subgraphs associated
     * with this attribute node's map key.
     * @return Map of subgraphs associated with this attribute
     * node's map key or empty Map if none have been defined
     */
    public Map<Class, Subgraph> getKeySubgraphs();
}
----

==== Subgraph Interface

[source,java]
----
package jakarta.persistence;

/**
 * This type represents a subgraph for an attribute node that
 * corresponds to a Managed Type. Using this class, an entity subgraph
 * can be embedded within an EntityGraph.
 *
 * @param <T> The type of the attribute.
 *
 * @see EntityGraph
 * @see AttributeNode
 * @see NamedSubgraph
 *
 * @since 2.1
 */
public interface Subgraph<T> extends Graph<T> {

    /**
     * Return the type for which this subgraph was defined.
     * @return managed type referenced by the subgraph
     */
    public Class<T> getClassType();

}
----

==== Use of Entity Graphs in find and query operations [[a2814]]

An entity graph can be used with the `find`
method or as a query hint to override or augment `FetchType` semantics.

The standard properties
`jakarta.persistence.fetchgraph` and `jakarta.persistence.loadgraph` are
used to specify such graphs to queries and `find` operations.

The default fetch graph for an entity or
embeddable is defined to consist of the transitive closure of all of its
attributes that are specified as `FetchType.EAGER` (or defaulted as
such).

The persistence provider is permitted to
fetch additional entity state beyond that specified by a fetch graph or
load graph. It is required, however, that the persistence provider fetch
all state specified by the fetch or load graph.

===== Fetch Graph Semantics

When the `jakarta.persistence.fetchgraph`
property is used to specify an entity graph, attributes that are
specified by attribute nodes of the entity graph are treated as
`FetchType.EAGER` and attributes that are not specified are treated as
`FetchType.LAZY`.

The following rules apply, depending on
attribute type. The rules of this section are applied recursively.

A primary key or version attribute never
needs to be specified in an attribute node of a fetch graph. (This
applies to composite primary keys as well, including embedded id primary
keys.) When an entity is fetched, its primary key and version attributes
are always fetched. It is not incorrect, however, to specify primary key
attributes or version attributes.

Attributes other than primary key and version
attributes are assumed not to be fetched unless the attribute is
specified. The following rules apply to the specification of attributes.

* If the attribute is an embedded attribute,
and the attribute is specified in an attribute node, but a subgraph is
not specified for the attribute, the default fetch graph for the
embeddable is fetched. If a subgraph is specified for the attribute, the
attributes of the embeddable are fetched according to their
specification in the corresponding subgraph.
* If the attribute is an element collection of
basic type, and the attribute is specified in an attribute node, the
element collection together with its basic elements is fetched.
* If the attribute is an element collection of
embeddables, and the attribute is specified in an attribute node, but a
subgraph is not specified for the attribute, the element collection
together with the default fetch graph of its embeddable elements is
fetched. If a subgraph is specified for the attribute, the attributes of
the embeddable elements are fetched according to the corresponding
subgraph specification.
* If the attribute is a one-to-one or
many-to-one relationship, and the attribute is specified in an attribute
node, but a subgraph is not specified for the attribute, the default
fetch graph of the target entity is fetched. If a subgraph is specified
for the attribute, the attributes of the target entity are fetched
according to the corresponding subgraph specification.
* If the attribute is a one-to-many or
many-to-many relationship, and the attribute is specified in an
attribute node, but a subgraph is not specified, the collection is
fetched and the default fetch graphs of the referenced entities are
fetched. If a subgraph is specified for the attribute, the entities in
the collection are fetched according to the corresponding subgraph
specification.
* If the key of a map which has been specified
in an attribute node is a basic type, it is fetched. If the key of a map
which has been specified in an attribute node is an embedded type, the
default fetch graph is fetched for the embeddable. Otherwise, if the key
of the map is an entity, and a map key subgraph is not specified for the
attribute node, the map key is fetched according to its default fetch
graph. If a key subgraph is specified for the map key attribute, the map
key attribute is fetched according to the map key subgraph
specification.


*Examples:*

[source,java]
----
@NamedEntityGraph
@Entity
public class Phonenumber {
    @Id
    protected String number;

    protected PhoneTypeEnum type;

    // ...
}
----

In the above example, only the `number` attribute would be eagerly fetched.

[source,java]
----
@NamedEntityGraph(
    attributeNodes={@NamedAttributeNode("projects")}
)
@Entity
public class Employee {
    @Id
    @GeneratedValue
    protected long id;

    @Basic
    protected String name;

    @Basic
    protected String employeeNumber;

    @OneToMany()
    protected List<Dependents> dependents;

    @OneToMany()
    protected List<Project> projects;

    @OneToMany()
    protected List<PhoneNumber> phoneNumbers;

    // ...
}

@Entity
@Inheritance
public class Project {
    @Id
    @GeneratedValue
    protected long id;

    String name;

    @OneToOne(fetch=FetchType.EAGER)
    protected Requirements doc;

    // ...
}

@Entity
public class LargeProject extends Project {
    @OneToOne(fetch=FetchType.LAZY)
    protected Employee approver;

    // ...
}

@Entity
public class Requirements {
    @Id
    protected long id;

    @Lob
    protected String description;

    @OneToOne(fetch=FetchType.LAZY)
    protected Approval approval

    // ...
}
----

In the above example, the `Employee` entity's
primary key will be fetched as well as the related `Project` instances,
whose default fetch graph (`id`, `name`, and `doc` attributes) will
be fetched. The related `Requirements` object will be fetched according
to its default fetch graph.

If the `approver` attribute of `LargeProject`
were `FetchType.EAGER`, and if any of the projects were instances of
`LargeProject`, their `approver` attributes would also be fetched.
Since the type of the `approver` attribute is `Employee`, the
approver's default fetch graph (`id`, `name`, and `employeeNumber`
attributes) would also be fetched.

===== Load Graph Semantics

When the `jakarta.persistence.loadgraph`
property is used to specify an entity graph, attributes that are
specified by attribute nodes of the entity graph are treated as
`FetchType.EAGER` and attributes that are not specified are treated
according to their specified or default FetchType.

The following rules apply. The rules of this
section are applied recursively.

* A primary key or version attribute never
needs to be specified in an attribute node of a load graph. (This
applies to composite primary keys as well, including embedded id primary
keys.) When an entity is fetched, its primary key and version attributes
are always fetched. It is not incorrect, however, to specify primary key
attributes or version attributes.
* If the attribute is an embedded attribute,
and the attribute is specified in an attribute node, but a subgraph is
not specified for the attribute, the default fetch graph for the
embeddable is fetched. If a subgraph is specified for the attribute,
attributes that are specified by the subgraph are also fetched.
* If the attribute is an element collection of
basic type, and the attribute is specified in an attribute node, the
element collection together with its basic elements is fetched.
* If the attribute is an element collection of
embeddables, and the attribute is specified in an attribute node, the
element collection together with the default fetch graph of its
embeddable elements is fetched. If a subgraph is specified for the
attribute, attributes that are specified by the subgraph are also
fetched.
* If the attribute is a one-to-one or
many-to-one relationship, and the attribute is specified in an attribute
node, the default fetch graph of the target entity is fetched. If a
subgraph is specified for the attribute, attributes that are specified
by the subgraph are also fetched.
* If the attribute is a one-to-many or
many-to-many relationship, and the attribute is specified in an
attribute node, the collection is fetched and the default fetch graphs
of the referenced entities are fetched. If a subgraph is specified for
the attribute, attributes that are specified by the subgraph are also
fetched.
* If the key of a map which has been specified
in an attribute node is a basic type, it is fetched. If the key of a map
which has been specified in an attribute node is an embedded type, the
default fetch graph is fetched for the embeddable. Otherwise, if the key
of the map is an entity, the map key is fetched according to its default
fetch graph. If a key subgraph is specified for the map key attribute,
additional attributes are fetched as specified in the key subgraph.

*Examples:*

[source,java]
----
@NamedEntityGraph
@Entity
public class Phonenumber {
    @Id
    protected String number;

    protected PhoneTypeEnum type;

    // ...
}
----

In the above example, the `number` and `type` attributes are fetched.

[source,java]
----
@NamedEntityGraph(
    attributeNodes={@NamedAttributeNode("projects")}
)
@Entity
public class Employee {
    @Id
    @GeneratedValue
    protected long id;

    @Basic
    protected String name;

    @Basic
    protected String employeeNumber;

    @OneToMany()
    protected List<Dependents> dependents;

    @OneToMany()
    protected List<Project> projects;

    @OneToMany()
    protected List<PhoneNumber> phoneNumbers;

    // ...
}

@Entity
@Inheritance
public class Project {
    @Id
    @GeneratedValue
    protected long id;

    String name;

    @OneToOne(fetch=FetchType.EAGER)
    protected Requirements doc;

    // ...
}

@Entity
public class LargeProject extends Project {
    @OneToOne(fetch=FetchType.LAZY)
    protected Employee approver;

    // ...
}

@Entity
public class Requirements {
    @Id
    protected long id;

    @Lob
    protected String description;

    @OneToOne(fetch=FetchType.LAZY)
    protected Approval approval

    // ...
}
----

In the above example, the default fetch graph
(`id`, `name`, `employeeNumber` attributes) of `Employee` is fetched.
The default fetch graphs of the related `Project` instances (`id`,
`name`, and `doc` attributes) and their `Requirements` instances (`id`
and `description` attributes) are also fetched.

=== Type Conversion of Basic Attributes [[a2999]]

The attribute conversion facility allows the developer to define custom
attribute converters. A `converter` is a class whose methods convert
between:

- the _target type_ of the converter, an arbitrary Java type which may be
  used as the type of a persistent field or property, and
- a basic type (see <<a486>>) used as an intermediate step in mapping to
  the database representation.

A converter can be used to convert attributes defined by entity classes,
mapped superclasses, or embeddable classes.footnote:[We plan to provide a
facility for more complex attribute conversions in a future release of
this specification.] A converted attribute is considered a basic attribute,
since, with the aid of the converter, its values can be represented as
instances of a basic type.

Every attribute converter class must implement the interface
`jakarta.persistence.AttributeConverter` and must be annotated with the
`Converter` annotation or declared as a converter in the XML descriptor.
If the value of the `autoApply` element of the `Converter` annotation is
`true`, the converter is automatically applied to all attributes of the
target type, including to basic attribute values that are contained within
other, more complex attribute types. See <<a13903>>.

[source,java]
----
package jakarta.persistence;

/**
 * A class that implements this interface can be used to convert
 * entity attribute state into database column representation
 * and back again.
 * Note that the X and Y types may be the same Java type.
 *
 * @param <X>  the type of the entity attribute
 * @param <Y>  the type of the database column
 */
public interface AttributeConverter<X,Y> {

    /**
     * Converts the value stored in the entity attribute into the
     * data representation to be stored in the database.
     *
     * @param attribute  the entity attribute value to be converted
     * @return  the converted data to be stored in the database
     *          column
     */
    public Y convertToDatabaseColumn (X attribute);

    /**
     * Converts the data stored in the database column into the
     * value to be stored in the entity attribute.
     * Note that it is the responsibility of the converter writer to
     * specify the correct <code>dbData</code> type for the corresponding
     * column for use by the JDBC driver: i.e., persistence providers are
     * not expected to do such type conversion.
     *
     * @param dbData  the data from the database column to be
     *                converted
     * @return  the converted value to be stored in the entity
     *          attribute
     */
    public X convertToEntityAttribute (Y dbData);
}
----

Attribute converter classes in Jakarta EE
environments support dependency injection through the Contexts and
Dependency Injection API (CDI) <<a19500>> when CDI is
enabledfootnote:[CDI is enabled by
default in Jakarta EE. See the Jakarta EE specification
<<a19499>>.]. An attribute converter class that makes
use of CDI injection may also define lifecycle callback methods
annotated with the `PostConstruct` and `PreDestroy` annotations. These
methods will be invoked after injection has taken place and before the
attribute converter instance is destroyed respectively.

The persistence provider is responsible for
using the CDI SPI to create instances of the attribute converter class;
to perform injection upon such instances; to invoke their
`PostConstruct` and `PreDestroy` methods, if any; and to dispose of the
attribute converter instances.

The persistence provider is only required to
support CDI injection into attribute converters in Jakarta EE container
environmentsfootnote:[The persistence
provider may support CDI injection into attribute converters in other
environments in which the BeanManager is available.]. If CDI is not enabled, the
persistence provider must not invoke attribute converters that depend
upon CDI injection.

An attribute converter is a noncontextual
object. In supporting injection into attribute converters, the
persistence provider must behave as if it carries out the following
steps involving the use of the CDI SPI. (See
<<a19500>>).

* Obtain a `BeanManager` instance. (See <<a12802>>.)
* Create an `AnnotatedType` instance for the attribute converter class.
* Create an `InjectionTarget` instance for the annotated type.
* Create a `CreationalContext`.
* Instantiate the listener by calling the `InjectionTarget` `produce` method.
* Inject the listener instance by calling the `InjectionTarget` `inject` method on the instance.
* Invoke the `PostConstruct` callback, if any,
by calling the `InjectionTarget` `postConstruct` method on the instance.

When the listener instance is to be
destroyed, the persistence provider must behave as if it carries out the
following steps.

* Call the `InjectionTarget` `preDestroy` method on the instance.
* Call the `InjectionTarget` `dispose` method on the instance.
* Call the `CreationalContext` `release` method.

Persistence providers may optimize the steps
above, e.g. by avoiding calls to the actual CDI SPI and relying on
container-specific interfaces instead, as long as the outcome is the
same.

Attribute converters that do not make use of
CDI injection are stateless. The lifecycle of such attribute converters
is unspecified.

The conversion of all basic types is
supported except for the following: Id attributes (including the
attributes of embedded ids and derived identities), version attributes,
relationship attributes, and attributes explicitly annotated as
`Enumerated` or `Temporal` or designated as such in the XML descriptor.
Auto-apply converters will not be applied to such attributes, and
applications that apply converters to such attributes through use of the
`Convert` annotation will not be portable.

Type conversion may be specified at the level
of individual attributes by means of the `Convert` annotation. The
`Convert` annotation may also be used to override or disable an
auto-apply conversion. See <<a14398>>.

The `Convert` annotation may be applied
directly to an attribute of an entity, mapped superclass, or embeddable
class to specify conversion of the attribute or to override the use of a
converter that has been specified as `autoApply=true`. When persistent
properties are used, the `Convert` annotation is applied to the getter
method.

The `Convert` annotation may be applied to an
entity that extends a mapped superclass to specify or override the
conversion mapping for an inherited basic or embedded attribute.

The persistence provider runtime is
responsible for invoking the specified conversion methods for the target
attribute type when loading the entity attribute from the database and
before storing the entity attribute state to the database. The
persistence provider must apply any conversion methods to instances of
attribute values in path expressions used within Jakarta Persistence query
language queries or criteria queries (such as in comparisons, bulk
updates, etc.) before sending them to the database for the query
execution. When such converted attributes are used in comparison
operations with literals or parameters, the value of the literal or
parameter to which they are compared must also be converted. If the
result of a Jakarta Persistence query language query or criteria query
includes one or more entity attributes for which conversion mappings
have been specified, the persistence provider must apply the specified
conversions to the corresponding values in the query result before
returning them to the application. The use of functions, including
aggregates, on converted attributes is undefined. If an exception is
thrown from a conversion method, the persistence provider must wrap the
exception in a PersistenceException and, if the persistence context is
joined to a transaction, mark the transaction for rollback.

=== Caching [[a3061]]

This specification supports the use of a
second-level cache by the persistence provider. The second-level cache,
if used, underlies the persistence context, and is largely transparent
to the application.

A second-level cache is typically used to
enhance performance. Use of a cache, however, may have consequences in
terms of the up-to-dateness of the data seen by the application,
resulting in “stale reads”. A stale read is defined as the reading of
entities or entity state that is older than the point at which the
persistence context was started.

This specification defines the following
portable configuration options that can be used by the application
developer to control caching behavior. Persistence providers may support
additional provider-specific options, but must observe all
specification-defined options.

==== The shared-cache-mode Element [[a3065]]

Whether the entities and entity-related state
of a persistence unit will be cached is determined by the value of the
`shared-cache-mode` element of the `persistence.xml` file.

The `shared-cache-mode` element has five
possible values: `ALL`, `NONE`, `ENABLE_SELECTIVE`,
`DISABLE_SELECTIVE`, `UNSPECIFIED`.

A value of `ALL` causes all entities and
entity-related state and data to be cached.

A value of `NONE` causes caching to be
disabled for the persistence unit. Persistence providers must not cache
if `NONE` is specified.

The values `ENABLE_SELECTIVE` and
`DISABLE_SELECTIVE` are used in conjunction with the `Cacheable`
annotation (or XML element). The `Cacheable` annotation specifies
whether an entity should be cached if such selective caching is enabled
by the `persistence.xml` `shared-cache-mode` element. The `Cacheable`
element is specified on the entity class. It applies to the given entity
and its subclasses unless subsequently overridden by a subclass.

* `Cacheable(false)` means that the entity and
its state must not be cached by the provider.
* A value of `ENABLE_SELECTIVE` enables the
cache and causes entities for which `Cacheable(true)` (or its XML
equivalent) is specified to be cached. Entities for which
`Cacheable(true)` is not specified or for which `Cacheable(false)` is
specified must not be cached.
* A value of `DISABLE_SELECTIVE` enables the
cache and causes all entities to be cached except those for which
`Cacheable(false)` is specified. Entities for which `Cacheable(false)`
is specified must not be cached.

If either the `shared-cache-mode` element is
not specified in the `persistence.xml` file or the value of the
`shared-cache-mode` element is `UNSPECIFIED`, and the
`jakarta.persistence.sharedCache.mode` property is not specified, the
behavior is not defined, and provider-specific defaults may apply. If
the `shared-cache-mode` element and the
`jakarta.persistence.sharedCache.mode` property are not specified, the
semantics of the `Cacheable` annotation (and XML equivalent) are
undefined.

The persistence provider is not required to
support use of a second-level cache. If the persistence provider does
not support use of a second-level cache or a second-level cache is not
installed, this element will be ignored and no caching will occur.

Further control over the second-level cache
is described in <<a12124>>.

==== Cache Retrieve Mode and Cache Store Mode Properties

Cache retrieve mode and cache store mode
properties may be specified at the level of the persistence context by
means of the EntityManager `setProperty` method. These properties may be
specified for the `EntityManager` `find` and `refresh` methods and the
`Query`, `TypedQuery`, `and` `StoredProcedureQuery` `setHint` methods.
Cache retrieve mode and/or cache store mode properties specified for the
`find`, `refresh`, and `Query`, `TypedQuery`, and
_StoredProcedureQuery setHint_ methods override those specified for the
persistence context for the specified `find` and `refresh` invocations,
and for the execution of the specified queries respectively.

If caching is disabled by the `NONE` value of
the `shared-cache-mode` element, cache retrieve mode and cache store
mode properties must be ignored. Otherwise, if the `ENABLE_SELECTIVE`
value is specified, but `Cacheable(true)` is not specified for a
particular entity, they are ignored for that entity; if the
`DISABLE_SELECTIVE` value is specified, they are ignored for any
entities for which `Cacheable(false)` is specified.

Cache retrieve mode and cache store mode
properties must be observed when caching is enabled, regardless of
whether caching is enabled due to the specification of the
`shared-cache-mode` element or enabled due to provider-specific options.
Applications that make use of cache retrieve mode or cache store mode
properties but which do not specify the `shared-cache-mode` element will
not be portable.

The cache retrieve mode and cache store mode
properties are `jakarta.persistence.cache.retrieveMode` and
`jakarta.persistence.cache.storeMode` respectively. These properties have
the semantics defined below.

The `retrieveMode` property specifies the
behavior when data is retrieved by the `find` methods and by the
execution of queries. The `retrieveMode` property is ignored for the
`refresh` method, which always causes data to be retrieved from the
database, not the cache.

[source,java]
----
package jakarta.persistence;

/**
 * Used as the value of the
 * <code>jakarta.persistence.cache.retrieveMode</code> property to
 * specify the behavior when data is retrieved by the
 * <code>find</code> methods and by queries.
 *
 * @since 2.0
 */
public enum CacheRetrieveMode {

    /**
     * Read entity data from the cache: this is
     * the default behavior.
     */
    USE,

    /**
     * Bypass the cache: get data directly from
     * the database.
     */
    BYPASS
}
----

The `storeMode` property specifies the
behavior when data is read from the database and when data is committed
into the database.

[source,java]
----
package jakarta.persistence;

/**
 * Used as the value of the
 * <code>jakarta.persistence.cache.storeMode</code> property to specify
 * the behavior when data is read from the database and when data is
 * committed into the database.
 *
 * @since 2.0
 */
public enum CacheStoreMode {

    /**
     * Insert entity data into cache when read from database
     * and insert/update entity data when committed into database:
     * this is the default behavior. Does not force refresh
     * of already cached items when reading from database.
     */
    USE,

    /**
     * Don't insert into cache.
     */
    BYPASS,

    /**
     * Insert/update entity data into cache when read
     * from database and when committed into database.
     * Forces refresh of cache for items read from database.
     */
    REFRESH
}
----

=== Query APIs [[a3125]]

The `Query` and `TypedQuery` APIs are used
for the execution of both static queries and dynamic queries. These APIs
also support parameter binding and pagination control. The
`StoredProcedureQuery` API is used for the execution of queries that
invoke stored procedures defined in the database.

==== Query Interface [[a3127]]

[source,java]
----
package jakarta.persistence;

import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.Map;
import java.util.stream.Stream;

/**
 * Interface used to control query execution.
 *
 * @see TypedQuery
 * @see StoredProcedureQuery
 * @see Parameter
 *
 * @since 1.0
 */
public interface Query {

    /**
     * Execute a SELECT query and return the query results
     * as an untyped List.
     * @return a list of the results
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    List getResultList();

    /**
     * Execute a SELECT query and return the query results
     * as an untyped <code>java.util.stream.Stream</code>.
     * By default this method delegates to <code>getResultList().stream()</code>,
     * however persistence provider may choose to override this method
     * to provide additional capabilities.
     *
     * @return a stream of the results
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     * @see Stream
     * @see #getResultList()
     * @since 2.2
     */
    default Stream getResultStream() {
        return getResultList().stream();
    }

    /**
     * Execute a SELECT query that returns a single untyped result.
     * @return the result
     * @throws NoResultException if there is no result
     * @throws NonUniqueResultException if more than one result
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    Object getSingleResult();

    /**
     * Execute a SELECT query that returns a single untyped result.
     * @return the result, or null if there is no result
     * @throws NonUniqueResultException if more than one result
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    Object getSingleResultOrNull();

    /**
     * Execute an update or delete statement.
     * @return the number of entities updated or deleted
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language SELECT statement or for
     *         a criteria query
     * @throws TransactionRequiredException if there is
     *         no transaction or the persistence context has not
     *         been joined to the transaction
     * @throws QueryTimeoutException if the statement execution
     *         exceeds the query timeout value set and only
     *         the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    int executeUpdate();

    /**
     * Set the maximum number of results to retrieve.
     * @param maxResult  maximum number of results to retrieve
     * @return the same query instance
     * @throws IllegalArgumentException if the argument is negative
     */
    Query setMaxResults(int maxResult);

    /**
     * The maximum number of results the query object was set to
     * retrieve. Returns <code>Integer.MAX_VALUE</code> if <code>setMaxResults</code> was not
     * applied to the query object.
     * @return maximum number of results
     * @since 2.0
     */
    int getMaxResults();

    /**
     * Set the position of the first result to retrieve.
     * @param startPosition position of the first result,
     * numbered from 0
     * @return the same query instance
     * @throws IllegalArgumentException if the argument is negative
     */
    Query setFirstResult(int startPosition);

    /**
     * The position of the first result the query object was set to
     * retrieve. Returns 0 if <code>setFirstResult</code> was not applied to the
     * query object.
     * @return position of the first result
     * @since 2.0
     */
    int getFirstResult();

    /**
     * Set a query property or hint. The hints elements may be used
     * to specify query properties and hints. Properties defined by
     * this specification must be observed by the provider.
     * Vendor-specific hints that are not recognized by a provider
     * must be silently ignored. Portable applications should not
     * rely on the standard timeout hint. Depending on the database
     * in use and the locking mechanisms used by the provider,
     * this hint may or may not be observed.
     * @param hintName  name of the property or hint
     * @param value  value for the property or hint
     * @return the same query instance
     * @throws IllegalArgumentException if the second argument is not
     *         valid for the implementation
     */
    Query setHint(String hintName, Object value);

    /**
     * Get the properties and hints and associated values that are
     * in effect for the query instance.
     * @return query properties and hints
     * @since 2.0
     */
    Map<String, Object> getHints();

    /**
     * Bind the value of a <code>Parameter</code> object.
     * @param param  parameter object
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter
     *         does not correspond to a parameter of the
     *         query
     * @since 2.0
     */
    <T> Query setParameter(Parameter<T> param, T value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a <code>Parameter</code> object.
     * @param param parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     * @since 2.0
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    Query setParameter(Parameter<Calendar> param, Calendar value,
                       TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a <code>Parameter</code> object.
     * @param param parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     * @since 2.0
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    Query setParameter(Parameter<Date> param, Date value,
                       TemporalType temporalType);

    /**
     * Bind an argument value to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the argument is of incorrect type
     */
    Query setParameter(String name, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    Query setParameter(String name, Calendar value,
                       TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    Query setParameter(String name, Date value,
                       TemporalType temporalType);

    /**
     * Bind an argument value to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the
     *         query or if the argument is of incorrect type
     */
    Query setParameter(int position, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a positional
     * parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query or
     *         if the value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    Query setParameter(int position, Calendar value,
                       TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query or
     *         if the value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    Query setParameter(int position, Date value,
                       TemporalType temporalType);

    /**
     * Get the parameter objects corresponding to the declared
     * parameters of the query.
     * Returns empty set if the query has no parameters.
     * This method is not required to be supported for native
     * queries.
     * @return set of the parameter objects
     * @throws IllegalStateException if invoked on a native
     *         query when the implementation does not support
     *         this use
     * @since 2.0
     */
    Set<Parameter<?>> getParameters();

    /**
     * Get the parameter object corresponding to the declared
     * parameter of the given name.
     * This method is not required to be supported for native
     * queries.
     * @param name  parameter name
     * @return parameter object
     * @throws IllegalArgumentException if the parameter of the
     *         specified name does not exist
     * @throws IllegalStateException if invoked on a native
     *         query when the implementation does not support
     *         this use
     * @since 2.0
     */
    Parameter<?> getParameter(String name);

    /**
     * Get the parameter object corresponding to the declared
     * parameter of the given name and type.
     * This method is required to be supported for criteria queries
     * only.
     * @param name  parameter name
     * @param type  type
     * @return parameter object
     * @throws IllegalArgumentException if the parameter of the
     *         specified name does not exist or is not assignable
     *         to the type
     * @throws IllegalStateException if invoked on a native
     *         query or Jakarta Persistence query language query when
     *         the implementation does not support this use
     * @since 2.0
     */
    <T> Parameter<T> getParameter(String name, Class<T> type);

    /**
     * Get the parameter object corresponding to the declared
     * positional parameter with the given position.
     * This method is not required to be supported for native
     * queries.
     * @param position  position
     * @return parameter object
     * @throws IllegalArgumentException if the parameter with the
     *         specified position does not exist
     * @throws IllegalStateException if invoked on a native
     *         query when the implementation does not support
     *         this use
     * @since 2.0
     */
    Parameter<?> getParameter(int position);

    /**
     * Get the parameter object corresponding to the declared
     * positional parameter with the given position and type.
     * This method is not required to be supported by the provider.
     * @param position  position
     * @param type  type
     * @return parameter object
     * @throws IllegalArgumentException if the parameter with the
     *         specified position does not exist or is not assignable
     *         to the type
     * @throws IllegalStateException if invoked on a native
     *         query or Jakarta Persistence query language query when
     *         the implementation does not support this use
     * @since 2.0
     */
    <T> Parameter<T> getParameter(int position, Class<T> type);

    /**
     * Return a boolean indicating whether a value has been bound
     * to the parameter.
     * @param param parameter object
     * @return boolean indicating whether parameter has been bound
     * @since 2.0
     */
    boolean isBound(Parameter<?> param);

    /**
     * Return the input value bound to the parameter.
     * (Note that OUT parameters are unbound.)
     * @param param parameter object
     * @return parameter value
     * @throws IllegalArgumentException if the parameter is not
     *         a parameter of the query
     * @throws IllegalStateException if the parameter has not been
     *         been bound
     * @since 2.0
     */
    <T> T getParameterValue(Parameter<T> param);

    /**
     * Return the input value bound to the named parameter.
     * (Note that OUT parameters are unbound.)
     * @param name  parameter name
     * @return parameter value
     * @throws IllegalStateException if the parameter has not been
     *         been bound
     * @throws IllegalArgumentException if the parameter of the
     *         specified name does not exist
     * @since 2.0
     */
    Object getParameterValue(String name);

    /**
     * Return the input value bound to the positional parameter.
     * (Note that OUT parameters are unbound.)
     * @param position  position
     * @return parameter value
     * @throws IllegalStateException if the parameter has not been
     *         been bound
     * @throws IllegalArgumentException if the parameter with the
     *         specified position does not exist
     * @since 2.0
     */
    Object getParameterValue(int position);

    /**
     * Set the flush mode type to be used for the query execution.
     * The flush mode type applies to the query regardless of the
     * flush mode type in use for the entity manager.
     * @param flushMode  flush mode
     * @return the same query instance
     */
    Query setFlushMode(FlushModeType flushMode);

    /**
     * Get the flush mode in effect for the query execution.
     * If a flush mode has not been set for the query object,
     * returns the flush mode in effect for the entity manager.
     * @return flush mode
     * @since 2.0
     */
    FlushModeType getFlushMode();

    /**
     * Set the lock mode type to be used for the query execution.
     * @param lockMode  lock mode
     * @return the same query instance
     * @throws IllegalStateException if the query is found not to be
     *         a Jakarta Persistence query language SELECT query
     *         or a CriteriaQuery query
     * @since 2.0
     */
    Query setLockMode(LockModeType lockMode);

    /**
     * Get the current lock mode for the query.  Returns null if a lock
     * mode has not been set on the query object.
     * @return lock mode
     * @throws IllegalStateException if the query is found not to be
     *         a Jakarta Persistence query language SELECT query or
     *         a Criteria API query
     * @since 2.0
     */
    LockModeType getLockMode();

    /**
     * Set the cache retrieval mode that is in effect during
     * query execution. This cache retrieval mode overrides the
     * cache retrieve mode in use by the entity manager.
     * @param cacheRetrieveMode cache retrieval mode
     * @return the same query instance
     * @since 3.2
     */
    Query setCacheRetrieveMode(CacheRetrieveMode cacheRetrieveMode);

    /**
     * Set the cache storage mode that is in effect during
     * query execution. This cache storage mode overrides the
     * cache storage mode in use by the entity manager.
     * @param cacheStoreMode cache storage mode
     * @return the same query instance
     * @since 3.2
     */
    Query setCacheStoreMode(CacheStoreMode cacheStoreMode);

    /**
     * The cache retrieval mode that will be in effect during
     * query execution.
     * @since 3.2
     */
    CacheRetrieveMode getCacheRetrieveMode();

    /**
     * The cache storage mode that will be in effect during
     * query execution.
     * @since 3.2
     */
    CacheStoreMode getCacheStoreMode();

    /**
     * Return an object of the specified type to allow access to
     * the provider-specific API.  If the provider's query
     * implementation does not support the specified class, the
     * <code>PersistenceException</code> is thrown.
     * @param cls  the class of the object to be returned.  This is
     *             normally either the underlying query
     *             implementation class or an interface that it
     *             implements.
     * @return an instance of the specified class
     * @throws PersistenceException if the provider does not support
     *         the call
     * @since 2.0
     */
    <T> T unwrap(Class<T> cls);
}
----

==== TypedQuery Interface

[source,java]
----
package jakarta.persistence;

import java.util.List;
import java.util.Date;
import java.util.Calendar;
import java.util.stream.Stream;

/**
 * Interface used to control the execution of typed queries.
 * @param <X> query result type
 *
 * @see Query
 * @see Parameter
 *
 * @since 2.0
 */
public interface TypedQuery<X> extends Query {

    /**
     * Execute a SELECT query and return the query results
     * as a typed List.
     * @return a list of the results
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the
     *         transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    List<X> getResultList();

    /**
     * Execute a SELECT query and return the query results
     * as a typed <code>java.util.stream.Stream</code>.
     * By default this method delegates to <code>getResultList().stream()</code>,
     * however persistence provider may choose to override this method
     * to provide additional capabilities.
     *
     * @return a stream of the results
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     * @see Stream
     * @see #getResultList()
     * @since 2.2
     */
    default Stream<X> getResultStream() {
        return getResultList().stream();
    }

    /**
     * Execute a SELECT query that returns a single result.
     * @return the result
     * @throws NoResultException if there is no result
     * @throws NonUniqueResultException if more than one result
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the
     *         transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    X getSingleResult();

    /**
     * Execute a SELECT query that returns a single untyped result.
     * @return the result, or null if there is no result
     * @throws NonUniqueResultException if more than one result
     * @throws IllegalStateException if called for a Jakarta
     *         Persistence query language UPDATE or DELETE statement
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws TransactionRequiredException if a lock mode other than
     *         <code>NONE</code> has been set and there is no transaction
     *         or the persistence context has not been joined to the transaction
     * @throws PessimisticLockException if pessimistic locking
     *         fails and the transaction is rolled back
     * @throws LockTimeoutException if pessimistic locking
     *         fails and only the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    X getSingleResultOrNull();

    /**
     * Set the maximum number of results to retrieve.
     * @param maxResult  maximum number of results to retrieve
     * @return the same query instance
     * @throws IllegalArgumentException if the argument is negative
     */
    TypedQuery<X> setMaxResults(int maxResult);

    /**
     * Set the position of the first result to retrieve.
     * @param startPosition position of the first result,
     *        numbered from 0
     * @return the same query instance
     * @throws IllegalArgumentException if the argument is negative
     */
    TypedQuery<X> setFirstResult(int startPosition);

    /**
     * Set a query property or hint. The hints elements may be used
     * to specify query properties and hints. Properties defined by
     * this specification must be observed by the provider.
     * Vendor-specific hints that are not recognized by a provider
     * must be silently ignored. Portable applications should not
     * rely on the standard timeout hint. Depending on the database
     * in use and the locking mechanisms used by the provider,
     * this hint may or may not be observed.
     * @param hintName  name of property or hint
     * @param value  value for the property or hint
     * @return the same query instance
     * @throws IllegalArgumentException if the second argument is not
     *         valid for the implementation
     */
    TypedQuery<X> setHint(String hintName, Object value);

    /**
     * Bind the value of a <code>Parameter</code> object.
     * @param param  parameter object
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter
     *         does not correspond to a parameter of the
     *         query
     */
     <T> TypedQuery<X> setParameter(Parameter<T> param, T value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a <code>Parameter</code> object.
     * @param param  parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    TypedQuery<X> setParameter(Parameter<Calendar> param,
                               Calendar value,
                               TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a <code>Parameter</code> object.
     * @param param  parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    TypedQuery<X> setParameter(Parameter<Date> param, Date value,
                               TemporalType temporalType);

    /**
     * Bind an argument value to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the argument is of incorrect type
     */
    TypedQuery<X> setParameter(String name, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    TypedQuery<X> setParameter(String name, Calendar value,
                               TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a named parameter.
     * @param name   parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if
     *         the value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    TypedQuery<X> setParameter(String name, Date value,
                               TemporalType temporalType);

    /**
     * Bind an argument value to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the
     *         query or if the argument is of incorrect type
     */
    TypedQuery<X> setParameter(int position, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a positional
     * parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query
     *         or if the value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    TypedQuery<X> setParameter(int position, Calendar value,
                               TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query
     *         or if the value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    TypedQuery<X> setParameter(int position, Date value,
                               TemporalType temporalType);

     /**
      * Set the flush mode type to be used for the query execution.
      * The flush mode type applies to the query regardless of the
      * flush mode type in use for the entity manager.
      * @param flushMode  flush mode
      * @return the same query instance
      */
     TypedQuery<X> setFlushMode(FlushModeType flushMode);

     /**
      * Set the lock mode type to be used for the query execution.
      * @param lockMode  lock mode
      * @return the same query instance
      * @throws IllegalStateException if the query is found not to
      *         be a Jakarta Persistence query language SELECT query
      *         or a CriteriaQuery query
      */
     TypedQuery<X> setLockMode(LockModeType lockMode);

    /**
     * Set the cache retrieval mode that is in effect during
     * query execution. This cache retrieval mode overrides the
     * cache retrieve mode in use by the entity manager.
     * @param cacheRetrieveMode cache retrieval mode
     * @return the same query instance
     * @since 3.2
     */
    TypedQuery<X> setCacheRetrieveMode(CacheRetrieveMode cacheRetrieveMode);

    /**
     * Set the cache storage mode that is in effect during
     * query execution. This cache storage mode overrides the
     * cache storage mode in use by the entity manager.
     * @param cacheStoreMode cache storage mode
     * @return the same query instance
     * @since 3.2
     */
    TypedQuery<X> setCacheStoreMode(CacheStoreMode cacheStoreMode);

}
----

==== Tuple Interface [[a3868]]

[source,java]
----
package jakarta.persistence;

import java.util.List;

/**
 * Interface for extracting the elements of a query result tuple.
 *
 * @see TupleElement
 *
 * @since 2.0
 */
public interface Tuple {

    /**
     * Get the value of the specified tuple element.
     * @param tupleElement  tuple element
     * @return value of tuple element
     * @throws IllegalArgumentException if tuple element
     *         does not correspond to an element in the
     *         query result tuple
     */
    <X> X get(TupleElement<X> tupleElement);

    /**
     * Get the value of the tuple element to which the
     * specified alias has been assigned.
     * @param alias  alias assigned to tuple element
     * @param type of the tuple element
     * @return value of the tuple element
     * @throws IllegalArgumentException if alias
     *         does not correspond to an element in the
     *         query result tuple or element cannot be
     *         assigned to the specified type
     */
    <X> X get(String alias, Class<X> type);

    /**
     * Get the value of the tuple element to which the
     * specified alias has been assigned.
     * @param alias  alias assigned to tuple element
     * @return value of the tuple element
     * @throws IllegalArgumentException if alias
     *         does not correspond to an element in the
     *         query result tuple
     */
    Object get(String alias);

    /**
     * Get the value of the element at the specified
     * position in the result tuple. The first position is 0.
     * @param i  position in result tuple
     * @param type  type of the tuple element
     * @return value of the tuple element
     * @throws IllegalArgumentException if i exceeds
     *         length of result tuple  or element cannot be
     *         assigned to the specified type
     */
    <X> X get(int i, Class<X> type);

    /**
     * Get the value of the element at the specified
     * position in the result tuple. The first position is 0.
     * @param i  position in result tuple
     * @return value of the tuple element
     * @throws IllegalArgumentException if i exceeds
     *         length of result tuple
     */
    Object get(int i);

    /**
     * Return the values of the result tuple elements as an array.
     * @return tuple element values
     */
    Object[] toArray();

    /**
     * Return the tuple elements.
     * @return tuple elements
     */
    List<TupleElement<?>> getElements();
}
----

==== TupleElement Interface [[a3949]]

[source,java]
----
package jakarta.persistence;

/**
 * The <code>TupleElement</code> interface defines an element that is returned in
 * a query result tuple.
 * @param <X> the type of the element
 *
 * @see Tuple
 *
 * @since 2.0
 */
public interface TupleElement<X> {

    /**
     * Return the Java type of the tuple element.
     * @return the Java type of the tuple element
     */
    Class<? extends X> getJavaType();

    /**
     * Return the alias assigned to the tuple element or null,
     * if no alias has been assigned.
     * @return alias
     */
    String getAlias();
}
----

==== Parameter Interface

[source,java]
----
package jakarta.persistence;

/**
 * Type for query parameter objects.
 * @param <T> the type of the parameter
 *
 * @see Query
 * @see TypedQuery
 *
 * @since 2.0
 */
public interface Parameter<T> {

    /**
     * Return the parameter name, or null if the parameter is
     * not a named parameter or no name has been assigned.
     * @return parameter name
     */
    String getName();

    /**
     * Return the parameter position, or null if the parameter
     * is not a positional parameter.
     * @return position of parameter
     */
    Integer getPosition();

    /**
     * Return the Java type of the parameter. Values bound to the
     * parameter must be assignable to this type.
     * This method is required to be supported for criteria queries
     * only.   Applications that use this method for Jakarta
     * Persistence query language queries and native queries will
     * not be portable.
     * @return the Java type of the parameter
     * @throws IllegalStateException if invoked on a parameter
     *         obtained from a query language
     *         query or native query when the implementation does
     *         not support this use
     */
     Class<T> getParameterType();
}
----

==== StoredProcedureQuery Interface

[source,java]
----
package jakarta.persistence;

import java.util.Calendar;
import java.util.Date;
import java.util.List;

/**
 * Interface used to control stored procedure query execution.
 *
 * <p>
 * Stored procedure query execution may be controlled in accordance with
 * the following:
 * <ul>
 * <li>The <code>setParameter</code> methods are used to set the values of
 * all required <code>IN</code> and <code>INOUT</code> parameters.
 * It is not required to set the values of stored procedure parameters
 * for which default values have been defined by the stored procedure.</li>
 * <li>
 * When <code>getResultList</code> and <code>getSingleResult</code> are
 * called on a <code>StoredProcedureQuery</code> object, the provider
 * will call <code>execute</code> on an unexecuted stored procedure
 * query before processing <code>getResultList</code> or
 * <code>getSingleResult</code>.</li>
 * <li>
 * When <code>executeUpdate</code> is called on a
 * <code>StoredProcedureQuery</code> object, the provider will call
 * <code>execute</code> on an unexecuted stored procedure query
 *  followed by <code>getUpdateCount</code>.  The results of
 * <code>executeUpdate</code> will be those of <code>getUpdateCount</code>.</li>
 * <li>
 * The <code>execute</code> method supports both the simple case where
 * scalar results are passed back only via <code>INOUT</code> and
 * <code>OUT</code> parameters as well as the most general case
 * (multiple result sets and/or update counts, possibly also in
 * combination with output parameter values).</li>
 * <li>
 * The <code>execute</code> method returns true if the first result is a
 * result set, and false if it is an update count or there are no results
 * other than through <code>INOUT</code> and <code>OUT</code> parameters,
 * if any.</li>
 * <li>
 * If the <code>execute</code> method returns true, the pending result set
 * can be obtained by calling <code>getResultList</code> or
 * <code>getSingleResult</code>.</li>
 * <li>
 * The <code>hasMoreResults</code> method can then be used to test
 * for further results.</li>
 * <li>
 * If <code>execute</code> or <code>hasMoreResults</code> returns false,
 * the <code>getUpdateCount</code> method can be called to obtain the
 * pending result if it is an update count.  The <code>getUpdateCount</code>
 * method will return either the update count (zero or greater) or -1
 * if there is no update count (i.e., either the next result is a result set
 * or there is no next update count).</li>
 * <li>
 * For portability, results that correspond to JDBC result sets and
 * update counts need to be processed before the values of any
 * <code>INOUT</code> or <code>OUT</code> parameters are extracted.</li>
 * <li>
 * After results returned through <code>getResultList</code> and
 * <code>getUpdateCount</code> have been exhausted, results returned through
 * <code>INOUT</code> and <code>OUT</code> parameters can be retrieved.</li>
 * <li>
 * The <code>getOutputParameterValue</code> methods are used to retrieve
 * the values passed back from the procedure through <code>INOUT</code>
 * and <code>OUT</code> parameters.</li>
 * <li>
 * When using <code>REF_CURSOR</code> parameters for result sets the
 * update counts should be exhausted before calling <code>getResultList</code>
 * to retrieve the result set.  Alternatively, the <code>REF_CURSOR</code>
 * result set can be retrieved through <code>getOutputParameterValue</code>.
 * Result set mappings will be applied to results corresponding to
 * <code>REF_CURSOR</code> parameters in the order the <code>REF_CURSOR</code>
 * parameters were registered with the query.</li>
 * <li>
 * In the simplest case, where results are returned only via
 * <code>INOUT</code> and <code>OUT</code> parameters, <code>execute</code>
 * can be followed immediately by calls to
 * <code>getOutputParameterValue</code>.</li>
 * </ul>
 *
 * @see Query
 * @see Parameter
 *
 * @since 2.1
 */
public interface StoredProcedureQuery extends Query {

    /**
     * Set a query property or hint. The hints elements may be used
     * to specify query properties and hints. Properties defined by
     * this specification must be observed by the provider.
     * Vendor-specific hints that are not recognized by a provider
     * must be silently ignored. Portable applications should not
     * rely on the standard timeout hint. Depending on the database
     * in use, this hint may or may not be observed.
     * @param hintName  name of the property or hint
     * @param value  value for the property or hint
     * @return the same query instance
     * @throws IllegalArgumentException if the second argument is not
     *         valid for the implementation
     */
    StoredProcedureQuery setHint(String hintName, Object value);

    /**
     * Bind the value of a <code>Parameter</code> object.
     * @param param  parameter object
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     */
    <T> StoredProcedureQuery setParameter(Parameter<T> param,
                                          T value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a <code>Parameter</code> object.
     * @param param parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    StoredProcedureQuery setParameter(Parameter<Calendar> param,
                                      Calendar value,
                                      TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a <code>Parameter</code> object.
     * @param param parameter object
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter does not
     *         correspond to a parameter of the query
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    StoredProcedureQuery setParameter(Parameter<Date> param,
                                      Date value,
                                      TemporalType temporalType);

    /**
     * Bind an argument value to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if the
     *         argument is of incorrect type
     */
    StoredProcedureQuery setParameter(String name, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if the
     *         value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    StoredProcedureQuery setParameter(String name,
                                      Calendar value,
                                      TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a named parameter.
     * @param name  parameter name
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if the parameter name does
     *         not correspond to a parameter of the query or if the
     *         value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    StoredProcedureQuery setParameter(String name,
                                      Date value,
                                      TemporalType temporalType);

    /**
     * Bind an argument value to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query
     *         or if the argument is of incorrect type
     */
    StoredProcedureQuery setParameter(int position, Object value);

    /**
     * Bind an instance of <code>java.util.Calendar</code> to a positional
     * parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query or
     *         if the value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    StoredProcedureQuery setParameter(int position,
                                      Calendar value,
                                      TemporalType temporalType);

    /**
     * Bind an instance of <code>java.util.Date</code> to a positional parameter.
     * @param position  position
     * @param value  parameter value
     * @param temporalType  temporal type
     * @return the same query instance
     * @throws IllegalArgumentException if position does not
     *         correspond to a positional parameter of the query or
     *         if the value argument is of incorrect type
     * @deprecated Newly-written code should use the date/time types
     *             defined in {@link java.time}.
     */
    @Deprecated(since = "3.2")
    StoredProcedureQuery setParameter(int position,
                                      Date value,
                                      TemporalType temporalType);

    /**
     * Set the flush mode type to be used for the query execution.
     * The flush mode type applies to the query regardless of the
     * flush mode type in use for the entity manager.
     * @param flushMode  flush mode
     * @return the same query instance
     */
    StoredProcedureQuery setFlushMode(FlushModeType flushMode);

    /**
     * Set the cache retrieval mode that is in effect during
     * query execution. This cache retrieval mode overrides the
     * cache retrieve mode in use by the entity manager.
     * @param cacheRetrieveMode cache retrieval mode
     * @return the same query instance
     * @since 3.2
     */
    StoredProcedureQuery setCacheRetrieveMode(CacheRetrieveMode cacheRetrieveMode);

    /**
     * Set the cache storage mode that is in effect during
     * query execution. This cache storage mode overrides the
     * cache storage mode in use by the entity manager.
     * @param cacheStoreMode cache storage mode
     * @return the same query instance
     * @since 3.2
     */
    StoredProcedureQuery setCacheStoreMode(CacheStoreMode cacheStoreMode);

    /**
     * Register a positional parameter.
     * All parameters must be registered.
     * @param position  parameter position
     * @param type  type of the parameter
     * @param mode  parameter mode
     * @return the same query instance
     */
    StoredProcedureQuery registerStoredProcedureParameter(
	  int position,
	  Class type,
	  ParameterMode mode);

    /**
     * Register a named parameter.
     * @param parameterName  name of the parameter as registered or
     *             specified in metadata
     * @param type  type of the parameter
     * @param mode  parameter mode
     * @return the same query instance
     */
    StoredProcedureQuery registerStoredProcedureParameter(
	  String parameterName,
	  Class type,
	  ParameterMode mode);

    /**
     *  Retrieve a value passed back from the procedure
     *  through an INOUT or OUT parameter.
     *  For portability, all results corresponding to result sets
     *  and update counts must be retrieved before the values of
     *  output parameters.
     *  @param position  parameter position
     *  @return the result that is passed back through the parameter
     *  @throws IllegalArgumentException if the position does
     *          not correspond to a parameter of the query or is
     *          not an INOUT or OUT parameter
     */
    Object getOutputParameterValue(int position);

    /**
     *  Retrieve a value passed back from the procedure
     *  through an INOUT or OUT parameter.
     *  For portability, all results corresponding to result sets
     *  and update counts must be retrieved before the values of
     *  output parameters.
     *  @param parameterName  name of the parameter as registered or
     *              specified in metadata
     *  @return the result that is passed back through the parameter
     *  @throws IllegalArgumentException if the parameter name does
     *          not correspond to a parameter of the query or is
     *          not an INOUT or OUT parameter
     */
    Object getOutputParameterValue(String parameterName);

    /**
     * Return true if the first result corresponds to a result set,
     * and false if it is an update count or if there are no results
     * other than through INOUT and OUT parameters, if any.
     * @return  true if first result corresponds to result set
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    boolean execute();

    /**
     * Return the update count of -1 if there is no pending result or
     * if the first result is not an update count.  The provider will
     * call <code>execute</code> on the query if needed.
     * @return the update count or -1 if there is no pending result
     * or if the next result is not an update count.
     * @throws TransactionRequiredException if there is
     *         no transaction or the persistence context has not
     *         been joined to the transaction
     * @throws QueryTimeoutException if the statement execution
     *         exceeds the query timeout value set and only
     *         the statement is rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    int executeUpdate();

    /**
     * Retrieve the list of results from the next result set.
     * The provider will call <code>execute</code> on the query
     * if needed.
     * A <code>REF_CURSOR</code> result set, if any, will be retrieved
     * in the order the <code>REF_CURSOR</code> parameter was
     * registered with the query.
     * @return a list of the results or null is the next item is not
     * a result set
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    List getResultList();

    /**
     * Retrieve a single result from the next result set.
     * The provider will call <code>execute</code> on the query
     * if needed.
     * A <code>REF_CURSOR</code> result set, if any, will be retrieved
     * in the order the <code>REF_CURSOR</code> parameter was
     * registered with the query.
     * @return the result or null if the next item is not a result set
     * @throws NoResultException if there is no result in the next
     *         result set
     * @throws NonUniqueResultException if more than one result
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    Object getSingleResult();

    /**
     * Retrieve a single result from the next result set.
     * The provider will call <code>execute</code> on the query
     * if needed.
     * A <code>REF_CURSOR</code> result set, if any, will be retrieved
     * in the order the <code>REF_CURSOR</code> parameter was
     * registered with the query.
     * @return the result or null if the next item is not a result set
     *         or if there is no result in the next result set
     * @throws NonUniqueResultException if more than one result
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    Object getSingleResultOrNull();

    /**
     * Return true if the next result corresponds to a result set,
     * and false if it is an update count or if there are no results
     * other than through INOUT and OUT parameters, if any.
     * @return  true if next result corresponds to result set
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    boolean hasMoreResults();

    /**
     * Return the update count or  -1 if there is no pending result
     * or if the next result is not an update count.
     * @return  update count or -1 if there is no pending result or if
     *          the next result is not an update count
     * @throws QueryTimeoutException if the query execution exceeds
     *         the query timeout value set and only the statement is
     *         rolled back
     * @throws PersistenceException if the query execution exceeds
     *         the query timeout value set and the transaction
     *         is rolled back
     */
    int getUpdateCount();

}
----

==== Query Execution

Jakarta Persistence query language, Criteria API, and native SQL
select queries are executed using the methods `getResultList`,
`getSingleResult`, and `getSingleResultOrNull`.
Update and delete operations (update and delete “queries”) are
executed using the `executeUpdate` method.

* For `TypedQuery` instances, the query result
type is determined in the case of criteria queries by the type of the
query specified when the `CriteriaQuery` object is created, as described
in <<a10621>>. In the case of Jakarta Persistence query language queries, the type of the
result is determined by the `resultClass` argument to the `createQuery`
or `createNamedQuery` method, and the select list of the query must
contain only a single item which must be assignable to the specified
type.
* For `Query` instances, the elements of a
query result whose select list consists of more than one select
expression are of type `Object[]`. If the select list consists of only
one select expression, the elements of the query result are of type
`Object`. When native SQL queries are used, the SQL result set mapping
(see <<a4427>>), determines
how many items (entities, scalar values, etc.) are returned. If multiple
items are returned, the elements of the query result are of type
`Object[]`. If only a single item is returned as a result of the SQL
result set mapping or if a result class is specified, the elements of
the query result are of type `Object`.

Stored procedure queries can be executed using the `getResultList`,
`getSingleResult`, `getSingleResultOrNull`, and `execute` methods.
Stored procedures that perform only updates or deletes can be executed
using the `executeUpdate` method. Stored procedure query execution is
described in detail in <<a4625>>.

An `IllegalArgumentException` is thrown if a
parameter instance is specified that does not correspond to a parameter
of the query, if a parameter name is specified that does not correspond
to a named parameter of the query, if a positional value is specified
that does not correspond to a positional parameter of the query, or if
the type of the parameter is not valid for the query. This exception may
be thrown when the parameter is bound, or the execution of the query may
fail. See <<a4397>>, <<a4401>>, and <<a4405>> for supported
parameter usage.

The effect of applying `setMaxResults` or
`setFirstResult` to a query involving fetch joins over collections is
undefined. The use of `setMaxResults` and `setFirstResult` is not
supported for stored procedure queries.

`Query` and `TypedQuery` methods other than
the `executeUpdate` method are not required to be invoked within a
transaction context, unless a lock mode other than `LockModeType.NONE`
has been specified for the query. In particular, the `getResultList`,
`getSingleResult`, and `getSingleResultOrNull` methods are not required
to be invoked within a transaction context unless such a lock mode has
been specified for the queryfootnote:[A lock mode is
specified for a query by means of the `setLockMode` method or by
specifying the lock mode in the `NamedQuery` annotation.]. If an entity manager with
transaction-scoped persistence context is in use, the resulting entities
will be detached; if an entity manager with an extended persistence
context is used, they will be managed. See <<a11431>> for further
discussion of entity manager use outside a transaction and persistence context types.

Whether a `StoredProcedureQuery` should be
invoked in a transaction context should be determined by the
transactional semantics and/or requirements of the stored procedure
implementation and the database in use. In particular, problems may
occur if the stored procedure initiates a transaction and a transaction
is already in effect. The state of any entities returned by the stored
procedure query invocation is determined as decribed above.

Runtime exceptions other than the
`NoResultException`, `NonUniqueResultException`,
`QueryTimeoutException`, and `LockTimeoutException` thrown by the
methods of the `Query`, `TypedQuery`, and `StoredProcedureQuery`
interfaces other than those methods specified below cause the current
transaction to be marked for rollback if the persistence context is
joined to the transaction. On database platforms on which a query
timeout causes transaction rollback, the persistence provider must throw
the `PersistenceException` instead of the `QueryTimeoutException`.

Runtime exceptions thrown by the following
methods of the `Query`, `TypedQuery`, and `StoredProcedureQuery`
interfaces do not cause the current transaction to be marked for
rollback: `getParameters`, `getParameter`, `getParameterValue`,
`getOutputParameterValue`, `getLockMode`.

Runtime exceptions thrown by the methods of
the `Tuple`, `TupleElement`, and `Parameter` interfaces do not cause
the current transaction to be marked for rollback.

For example:

[source,java]
----
public List findWithName(String name) {
    return em.createQuery("SELECT c FROM Customer c WHERE c.name LIKE :custName")
        .setParameter("custName", name)
        .setMaxResults(10)
        .getResultList();
}
----

==== Queries and Flush Mode [[a4374]]

The flush mode setting affects the result of
a query as follows.

When queries are executed within a
transaction, if `FlushModeType.AUTO` is set on the `Query`,
`TypedQuery`, or `StoredProcedureQuery` object, or if the flush mode
setting for the persistence context is `AUTO` (the default) and a flush
mode setting has not been specified for the query object, the
persistence provider is responsible for ensuring that all updates to the
state of all entities in the persistence context which could potentially
affect the result of the query are visible to the processing of the
query. The persistence provider implementation may achieve this by
flushing those entities to the database or by some other means. If
`FlushModeType.COMMIT` is set, the effect of updates made to entities in
the persistence context upon queries is unspecified.

If the persistence context has not been
joined to the current transaction, the persistence provider must not
flush to the database regardless of the flush mode setting.

[source,java]
----
package jakarta.persistence;

public enum FlushModeType {

    /**
     * Flushing to occur at transaction commit.  The provider may flush
     * at other times, but is not required to.
     */
    COMMIT,

    /**
     * (Default) Flushing to occur at query execution.
     */
    AUTO
}
----

If there is no transaction active, the
persistence provider must not flush to the database.

==== Queries and Lock Mode [[a4385]]

The `setLockMode` method of the
`Query` or `TypedQuery` interface or the `lockMode` element of the
`NamedQuery` annotation may be used to lock the results of a query. A
lock is obtained for each entity specified in the query result
(including entities passed to constructors in the query SELECT
clause).footnote:[Note that the
setLockMode method may be called more than once (with different values)
on a Query or TypedQuery object.]

If the lock mode type is `PESSIMISTIC_READ`,
`PESSIMISTIC_WRITE`, or `PESSIMISTIC_FORCE_INCREMENT`, and the query
returns scalar data (e.g., the values of entity field or properties,
including scalar data passed to constructors in the query SELECT
clause), the underlying database rows will be
lockedfootnote:[Note that locking
will not occur for data passed to aggregate functions. Further, queries
involving aggregates with pessimistic locking may not be supported on
all database platforms.], but the version columns (if any) for any
entities corresponding to such scalar data will not be updated unless
the entities themselves are also otherwise retrieved and updated.

If the lock mode type is `OPTIMISTIC` or
`OPTIMISTIC_FORCE_INCREMENT`, and the query returns scalar data, any
entities returned by the query will be locked, but no locking will occur
for scalar data that does not correspond to the state of any entity
instance in the query result.

If a lock mode other than `NONE` is specified
for a query, the query must be executed within a transaction (and the
persistence context must be joined to the transaction) or the
`TransactionRequiredException` will be thrown.

Locking is supported for Jakarta Persistence
query language queries and criteria queries only. If the `setLockMode`
or `getLockMode` method is invoked on a query that is not a Jakarta
Persistence query language select query or a criteria query, the
`IllegalStateException` may be thrown or the query execution will fail.

==== Query Hints [[a4391]]

The following hint is defined by this specification for use in query configuration.

 jakarta.persistence.query.timeout // time in milliseconds

This hint may be used with the `Query`,
`TypedQuery`, or `StoredProcedureQuery` `setHint` method or the
`NamedQuery`, `NamedNativeQuery`, and `NamedStoredProcedureQuery`
annotations. It may also be passed as a property to the
`Persistence.createEntityManagerFactory` method and used in the
`properties` element of the `persistence.xml` file. See <<a3127>>,
<<a12384>>, <<a13443>>, <<a13710>>. When used in
the `createEntityManagerFactory` method, the `persistence.xml` file, and
annotations, the `timeout` hint serves as a default value which can be
selectively overridden by use in the `setHint` method.

Portable applications should not rely on this
hint. Depending on the persistence provider and database in use, the
hint may or may not be observed.

Vendors are permitted to support the use of
additional, vendor-specific hints. Vendor-specific hints must not use
the `jakarta.persistence` namespace. Vendor-specific hints must be ignored
if they are not understood.

==== Parameter Objects [[a4397]]

`Parameter` objects can be used for criteria
queries and for Jakarta Persistence query language queries.

Implementations may support the use of
`Parameter` objects for native queries, however support for `Parameter`
objects with native queries is not required by this specification. The
use of `Parameter` objects for native queries will not be portable. The
mixing of parameter objects with named or positional parameters is invalid.

Portable applications should not attempt to
reuse a `Parameter` object obtained from a `Query` or `TypedQuery`
instance in the context of a different `Query` or `TypedQuery` instance.

==== Named Parameters [[a4401]]

Named parameters can be used for Jakarta
Persistence query language queries, for criteria queries (although use
of `Parameter` objects is to be preferred), and for stored procedure
queries that support named parameters.

Named parameters follow the rules for
identifiers defined in <<a4760>>.
Named parameters are case-sensitive. The mixing of named and positional
parameters is invalid.

A named parameter of a Jakarta Persistence query
language query is an identifier that is prefixed by the " _:_ " symbol.
The parameter names passed to the `setParameter` methods of the `Query`
and `TypedQuery` interfaces do not include this " _:_ " prefix.

==== Positional Parameters [[a4405]]

Only positional parameter binding and
positional access to result items may be portably used for native
queries, except for stored procedure queries for which named parameters
have been defined. When binding the values of positional parameters, the
numbering starts as “ `1` ”. It is assumed that for native queries the
parameters themselves use the SQL syntax (i.e., “ _?_ ”, rather than “
_?1_ ”).

The use of positional parameters is not supported for criteria queries.

==== Named Queries

Named queries are static queries expressed in
metadata or queries registered by means of the EntityManagerFactory
`addNamedQuery` method. Named queries can be defined in the Jakarta
Persistence query language or in SQL. Query names are scoped to the
persistence unit.

The following is an example of the definition
of a named query defined in metadata:

[source,java]
----
@NamedQuery(
    name="findAllCustomersWithName",
    query="SELECT c FROM Customer c WHERE c.name LIKE :custName"
)
----

The following is an example of the use of a named query:

[source,java]
----
@PersistenceContext
public EntityManager em;
    // ...

    customers = em.createNamedQuery("findAllCustomersWithName")
        .setParameter("custName", "Smith")
        .getResultList();
----

==== Polymorphic Queries

By default, all queries are polymorphic. That
is, the FROM clause of a query designates not only instances of the
specific entity class(es) to which it explicitly refers, but subclasses
as well. The instances returned by a query include instances of the
subclasses that satisfy the query conditions.

For example, the following query returns the
average salary of all employees, including subtypes of `Employee`, such
as `Manager` and `Exempt`.

[source,sql]
----
select avg(e.salary) from Employee e where e.salary > 80000
----

Entity type expressions, described in <<a5381>>, as well as the
use of downcasting, described in <<a4965>>, can be used to restrict query polymorphism.

==== SQL Queries [[a4427]]

Queries may be expressed in native SQL. The
result of a native SQL query may consist of entities, unmanaged
instances created via constructors, scalar values, or some combination
of these.

[NOTE]
====
The SQL query facility is intended to provide
support for those cases where it is necessary to use the native SQL of
the target database in use (and/or where the Jakarta Persistence query
language cannot be used). Native SQL queries are not expected to be
portable across databases.
====

===== Returning Managed Entities from Native Queries

The persistence provider is responsible for
performing the mapping between the values returned by the SQL query and
entity attributes in accordance with the object/relational mapping
metadata for the entity or entities. In particular, the names of the
columns in the SQL result are used to map to the entity attributes as
defined by this metadata. This mapping includes the mapping of the
attributes of any embeddable classes that are part of the
non-collection-valued entity state and attributes corresponding to
foreign keys contained as part of the entity
statefootnote:[Support for joins is
currently limited to single-valued relationships that are mapped
directly—i.e., not via join tables.].

When an entity is to be returned from a
native query, the SQL statement should select all of the columns that
are mapped to the entity object. This should include foreign key columns
to related entities. The results obtained when insufficient data is
available are undefined.

In the simplest case—i.e., when the results
of the query are limited to entities of a single entity class and the
mapping information can be derived from the columns of the SQL result
and the object/relational mapping metadata—it is sufficient to specify
only the expected class of the entity result.

The following example illustrates the case
where a native SQL query is created dynamically using the
`createNativeQuery` method and the entity class that specifies the type
of the result is passed in as an argument.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id, o.quantity, o.item " +
        "FROM Order o, Item i " +
        "WHERE (o.item = i.id) AND (i.name = 'widget')",
    com.acme.Order.class);
----

When executed, this query will return a
collection of all `Order` entities for items named “widget”.

The `SqlResultSetMapping` metadata
annotation—which is designed to handle more complex cases—can be used as
an alternative here. See <<a13797>> for the definition of the
`SqlResultSetMapping` metadata annotation and related annotations.

For the query shown above, the
`SqlResultSetMapping` metadata for the query result type might be
specified as follows:

[source,java]
----
@SqlResultSetMapping(
    name="WidgetOrderResults",
    entities=@EntityResult(entityClass=com.acme.Order.class))
----

The same results as produced by the query
above can then obtained by the following:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id, o.quantity, o.item " +
        "FROM Order o, Item i " +
        "WHERE (o.item = i.id) AND (i.name = 'widget')",
    "WidgetOrderResults");
----

When multiple entities are returned by a SQL
query or when the column names of the SQL result do not correspond to
those of the object/relational mapping metadata, a `SqlResultSetMapping`
metadata definition must be provided to specify the entity mapping.

The following query and `SqlResultSetMapping`
metadata illustrates the return of multiple entity types. It assumes
default metadata and column name defaults.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id, o.quantity, o.item, i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (o.quantity > 25) AND (o.item = i.id)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

When the column names of the SQL result do
not correspond to those of the object/relational mapping metadata
or introduce a conflict in mapping column defaults as in the example code above,
more explicit SQL result mapping metadata must be provided to enable the
persistence provider runtime to map the JDBC results into the expected
objects. This might arise, for example, when column aliases must be used
in the SQL SELECT clause when the SQL result would otherwise contain
multiple columns of the same name or when columns in the SQL result are
the results of operators or functions. The `FieldResult` annotation
element within the `EntityResult` annotation is used to specify the
mapping of such columns to entity attributes.

The following example combining multiple
entity types includes aliases in the SQL statement. This requires that
the column names be explicitly mapped to the entity fields corresponding
to those columns. The `FieldResult` annotation is used for this purpose.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item AS order_item, " +
        "i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item = i.id)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class, fields={
        @FieldResult(name="id", column="order_id"),
        @FieldResult(name="quantity", column="order_quantity"),
        @FieldResult(name="item", column="order_item")}),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

When the returned entity type contains an
embeddable class, the `FieldResult` element must use a dot (“ `.` ”)
notation to indicate which column maps to which field or property of the
contained embeddable.

*Example:*

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT c.id AS customer_id, " +
        "c.street AS customer_street, " +
        "c.city AS customer_city, " +
        "c.state AS customer_state, " +
        "c.status AS customer_status " +
        "FROM Customer c " +
        "WHERE c.status = 'GOLD' ",
    "CustomerResults");

@SqlResultSetMapping(name=”CustomerResults”, entities={
    @EntityResult(entityClass=com.acme.Customer.class, fields={
        @FieldResult(name="id", column="customer_id"),
        @FieldResult(name="address.street", column="customer_street"),
        @FieldResult(name="address.city", column="customer_city"),
        @FieldResult(name="address.state", column="customer_state"),
        @FieldResult(name="status", column="customer_status")
    })
})
----

When the returned entity type is the owner of
a single-valued relationship and the foreign key is a composite foreign
key (composed of multiple columns), a `FieldResult` element should be
used for each of the foreign key columns. The `FieldResult` element must
use the dot (“ `.` ”) notation form to indicate the column that maps to
each property or field of the target entity primary key.

If the target entity has a primary key of
type `IdClass`, this specification takes the form of the name of the
field or property for the relationship, followed by a dot (“ `.` ”),
followed by the name of the field or property of the primary key in the
target entity. The latter will be annotated with `Id`, as specified in
<<a14836>>.

Example:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item_id AS order_item_id, " +
        "o.item_name AS order_item_name, " +
        "i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item_id = i.id) " +
        "AND (order_item_name = i.name)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class, fields={
        @FieldResult(name="id", column="order_id"),
        @FieldResult(name="quantity", column="order_quantity"),
        @FieldResult(name="item.id", column="order_item_id")}),
        @FieldResult(name="item.name", column="order_item_name")}),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

If the target entity has a primary key of
type `EmbeddedId`, this specification is composed of the name of the
field or property for the relationship, followed by a dot (“ `.` ”),
followed by the name or the field or property of the primary key (i.e.,
the name of the field or property annotated as `EmbeddedId`), followed
by the name of the corresponding field or property of the embedded
primary key class.

Example:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item_id AS order_item_id, " +
        "o.item_name AS order_item_name, " +
        "i.id, i.name, i.description " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item_id = i.id) AND (order_item_name = i.name)",
    "OrderItemResults");

@SqlResultSetMapping(name="OrderItemResults", entities={
    @EntityResult(entityClass=com.acme.Order.class, fields={
        @FieldResult(name="id", column="order_id"),
        @FieldResult(name="quantity", column="order_quantity"),
        @FieldResult(name="item.itemPk.id", column="order_item_id")}),
        @FieldResult(name="item.itemPk.name", column="order_item_name")}),
    @EntityResult(entityClass=com.acme.Item.class)
})
----

The `FieldResult` elements for the composite
foreign key are combined to form the primary key `EmbeddedId` class for
the target entity. This may then be used to subsequently retrieve the
entity if the relationship is to be eagerly loaded.

The dot-notation form is not required to be
supported for any usage other than for embeddables, composite foreign
keys, or composite primary keys.

===== Returning Unmanaged Instances

Instances of other classes (including
non-managed entity instances) as well as scalar results can be returned
by a native query. These can be used singly, or in combination,
including with entity results.

====== Scalar Results

Scalar results can be included in the query
result by specifying the `ColumnResult` annotation element of the
`SqlResultSetMapping` annotation. The intended type of the result can be
specified using the `type` element of the `ColumnResult` annotation.

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT o.id AS order_id, " +
        "o.quantity AS order_quantity, " +
        "o.item AS order_item, " +
        "i.name AS item_name, " +
        "i.availabilityDate AS item_shipdate " +
        "FROM Order o, Item i " +
        "WHERE (order_quantity > 25) AND (order_item = i.id)",
    "OrderResults");

@SqlResultSetMapping(
    name="OrderResults",
    entities={
        @EntityResult(entityClass=com.acme.Order.class, fields={
            @FieldResult(name="id", column="order_id"),
            @FieldResult(name="quantity", column="order_quantity"),
            @FieldResult(name="item", column="order_item")}
        )},
    columns={
        @ColumnResult(name="item_name"),
        @ColumnResult(name="item_shipdate", type=java.util.Date.class)
    })
----

====== Constructor Results

The mapping to constructors is specified
using the `ConstructorResult` annotation element of the
`SqlResultSetMapping` annotation. The `targetClass` element of the
`ConstructorResult` annotation specifies the class whose constructor
corresponds to the specified columns. All columns corresponding to
arguments of the intended constructor must be specified using the
`columns` element of the `ConstructorResult` annotation in the same
order as that of the argument list of the constructor. Any entities
returned as constructor results will be in either the new or the
detached state, depending on whether a primary key is retrieved for the
constructed object.

Example:

[source,java]
----
Query q = em.createNativeQuery(
    "SELECT c.id, c.name, COUNT(o) as orderCount, AVG(o.price) AS avgOrder " +
        "FROM Customer c, Orders o " +
        "WHERE o.cid = c.id " +
        "GROUP BY c.id, c.name",
    "CustomerDetailsResult");

@SqlResultSetMapping(name="CustomerDetailsResult", classes={
    @ConstructorResult(targetClass=com.acme.CustomerDetails.class, columns={
        @ColumnResult(name="id"),
        @ColumnResult(name="name"),
        @ColumnResult(name="orderCount"),
        @ColumnResult(name="avgOrder", type=Double.class)})
})
----

===== Combinations of Result Types

When a `SqlResultSetMapping` specifies more
than one mapping type (i.e., more than one of `EntityResult`,
`ConstructorResult`, `ColumnResult`), then for each row in the SQL
result, the query execution will result in an `Object[]` instance whose
elements are as follows, in order: any entity results (in the order in
which they are defined in the `entities` element); any instances of
classes corresponding to constructor results (in the order defined in
the `classes` element); and any instances corresponding to column
results (in the order defined in the `columns` element). If there are
any columns whose result mappings have not been specified, they are
ignored.

===== Restrictions

When an entity is being returned, the SQL
statement should select all of the columns that are mapped to the entity
object. This should include foreign key columns to related entities. The
results obtained when insufficient data is available are undefined. A
SQL result set mapping must not be used to map results to the
non-persistent state of an entity.

The use of named parameters is not defined
for native SQL queries. Only positional parameter binding for SQL
queries may be used by portable applications.

==== Stored Procedures

The `StoredProcedureQuery` interface supports
the use of database stored procedures.

Stored procedures can be specified either by
means of the `NamedStoredProcedureQuery` annotation or dynamically.
Annotations for the specification of stored procedures are described in
<<a13759>>.

===== Named Stored Procedure Queries

Unlike in the case of a named native query,
the `NamedStoredProcedureQuery` annotation names a stored procedure that
exists in the database rather than providing a stored procedure
definition. The `NamedStoredProcedureQuery` annotation specifies the
types of all parameters to the stored procedure, their corresponding
parameter modes (IN, OUT, INOUT, REF_CURSORfootnote:[Note that REF_CURSOR
parameters are used by some databases to return result sets from stored
procedures.]), and
how result sets, if any, are to be mapped. The name that is assigned to
the stored procedure in the `NamedStoredProcedureQuery` annotation is
passed as an argument to the `createNamedStoredProcedureQuery` method to
create an executable `StoredProcedureQuery` object.

A stored procedure may return more than one
result set. As with native queries, the mapping of result sets can be
specified either in terms of a `resultClasses` or as a
`resultSetMappings` annotation element. If there are multiple result
sets, it is assumed that they will be mapped using the same mechanism —
e.g., all via a set of result class mappings or all via a set of result
set mappings. The order of the specification of these mappings must be
the same as the order in which the result sets will be returned by the
stored procedure invocation. If the stored procedure returns one or more
result sets and no `resultClasses` or `resultSetMappings` element has
been specified, any result set will be returned as a list of type
`Object[]`. The combining of different strategies for the mapping of
stored procedure result sets is undefined.

`StoredProcedureParameter` metadata needs to
be provided for all parameters. Parameters must be specified in the
order in which they occur in the parameter list of the stored procedure.
If parameter names are used, the parameter name is used to bind the
parameter value and to extract the output value (if the parameter is an
INOUT or OUT parameter). If parameter names are not specified, it is
assumed that positional parameters are used. The mixing of named and
positional parameters is invalid.

===== Dynamically-specified Stored Procedure Queries

If the stored procedure is not defined using
metadata, parameter and result set information must be provided
dynamically.

All parameters of a dynamically-specified
stored procedure query must be registered using the
`registerStoredProcedureParameter` method of the `StoredProcedureQuery`
interface.

Result set mapping information can be
provided by means of the `createStoredProcedureQuery` method.

===== Stored Procedure Query Execution [[a4625]]

Stored procedure query execution can be
controlled as described below.

The `setParameter` methods are used to set
the values of all required IN and INOUT parameters. It is not required
to set the values of stored procedure parameters for which default
values have been defined by the stored procedure.

When `getResultList`, `getSingleResult`, and `getSingleResultOrNull`
are called on a `StoredProcedureQuery` object, the persistence provider
will call `execute` on an unexecuted stored procedure query before
processing `getResultList`, `getSingleResult` or `getSingleResultOrNull`.

When `executeUpdate` is called on a
`StoredProcedureQuery` object, the persistence provider will call
`execute` on an unexecuted stored procedure query followed by
`getUpdateCount`. The results of `executeUpdate` will be those of
`getUpdateCount`.

The `execute` method supports both the simple
case where scalar results are passed back only via INOUT and OUT
parameters as well as the most general case (multiple result sets and/or
update counts, possibly also in combination with output parameter
values).

The `execute` method returns `true` if the
first result is a result set, and `false` if it is an update count or
there are no results other than through INOUT and OUT parameters, if
any.

If the `execute` method returns `true`, the pending result set can be
obtained by calling `getResultList`, `getSingleResult`, or
`getSingleResultOrNull`. The `hasMoreResults` method can then be used to
test for further results.

If `execute` or `hasMoreResults` returns
`false`, the `getUpdateCount` method can be called to obtain the
pending result if it is an update count. The `getUpdateCount` method
will return either the update count (zero or greater) or -1 if there is
no update count (i.e., either the next result is a result set or there
is no next update count).

For portability, results that correspond to
JDBC result sets and update counts need to be processed before the
values of any INOUT or OUT parameters are extracted.

After results returned through
`getResultList` and `getUpdateCount` have been exhausted, results
returned through INOUT and OUT parameters can be retrieved.

The `getOutputParameterValue` methods are
used to retrieve the values passed back from the procedure through INOUT
and OUT parameters.

When using `REF_CURSOR` parameters for result
sets, the update counts should be exhausted before calling
`getResultList` to retrieve the result set. Alternatively, the
`REF_CURSOR` result set can be retrieved through
`getOutputParameterValue`. Result set mappings will be applied to
results corresponding to `REF_CURSOR` parameters in the order the
`REF_CURSOR` parameters were registered with the query.

In the simplest case, where results are
returned only via INOUT and OUT parameters, `execute` can be followed
immediately by calls to `getOutputParameterValue`.

=== Summary of Exceptions [[a4639]]

The following is a summary of the exceptions defined by this specification:

*PersistenceException*

The `PersistenceException` is thrown by the
persistence provider when a problem occurs. It may be thrown to report
that the invoked operation could not complete because of an unexpected
error (e.g., failure of the persistence provider to open a database
connection).

All other exceptions defined by this
specification are subclasses of the `PersistenceException`. All
instances of `PersistenceException` except for instances of
`NoResultException`, `NonUniqueResultException`, `LockTimeoutException`
, and `QueryTimeoutException` will cause the current transaction, if one
is active and the persistence context has been joined to it, to be
marked for rollback.

*TransactionRequiredException*

The `TransactionRequiredException` is thrown
by the persistence provider when a transaction is required but is not
active.

*OptimisticLockException*

The `OptimisticLockException` is thrown by
the persistence provider when an optimistic locking conflict occurs.
This exception may be thrown as part of an API call, at flush, or at
commit time. The current transaction, if one is active, will be marked
for rollback.

*PessimisticLockException*

The `PessimisticLockException` is thrown by
the persistence provider when a pessimistic locking conflict occurs. The
current transaction will be marked for rollback. Typically the
`PessimisticLockException` occurs because the database transaction has
been rolled back due to deadlock or because the database uses
transaction-level rollback when a pessimistic lock cannot be granted.

*LockTimeoutException*

The `LockTimeoutException` is thrown by the
persistence provider when a pessimistic locking conflict occurs that
does not result in transaction rollback. Typically this occurs because
the database uses statement-level rollback when a pessimistic lock
cannot be granted (and there is no deadlock). The `LockTimeoutException`
does not cause the current transaction to be marked for rollback.

*RollbackException*

The `RollbackException` is thrown by the
persistence provider when `EntityTransaction.commit` fails.

*EntityExistsException*

The `EntityExistsException` may thrown by the
persistence provider when the `persist` operation is invoked and the
entity already exists. The `EntityExistsException` may be thrown when
the persist operation is invoked, or the `EntityExistsException` or
another `PersistenceException` may be thrown at commit time. The current
transaction, if one is active and the persistence context has been
joined to it, will be marked for rollback.

*EntityNotFoundException*

The `EntityNotFoundException` is thrown by
the persistence provider when an entity reference obtained by
`getReference` is accessed but the entity does not exist. It is thrown
by the `refresh` operation when the entity no longer exists in the
database. It is also thrown by the `lock` operation when pessimistic
locking is used and the entity no longer exists in the database. The
current transaction, if one is active and the persistence context has
been joined to it, will be marked for rollback.

*NoResultException*

The `NoResultException` is thrown by the persistence provider when
`Query.getSingleResult` is invoked and there is no result to return.
This exception will not cause the current transaction, if one is
active, to be marked for rollback.

*NonUniqueResultException*

The `NonUniqueResultException` is thrown by the persistence provider
when `Query.getSingleResult` or `Query.getSingleResultOrNull` is
invoked and there is more than one result from the query. This
exception will not cause the current transaction, if one is active,
to be marked for rollback.

*QueryTimeoutException*

The `QueryTimeoutException` is thrown by the
persistence provider when a query times out and only the statement is
rolled back. The `QueryTimeoutException` does not cause the current
transaction, if one is active, to be marked for rollback.
